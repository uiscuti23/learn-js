// * Перебираемые (итерируемые) объекты

/*
Перебираемые (или итерируемые) объекты – это обобщение массивов.
Концепция, которая позволяет использовать любой объект в цикле for..of.

Конечно же, сами массивы являются перебираемыми объектами.
Но есть и много других встроенных перебираемых объектов, например, строки.

Если объект не является массивом, но представляет собой коллекцию каких-то элементов
(список, набор), то удобно использовать цикл for..of для их перебора
*/

//_ Symbol.iterator

// Мы легко поймём принцип устройства перебираемых объектов, создав один из них:

let range = {
  from: 1,
  to: 5,
};

/* 
Чтобы сделать range итерируемым (и позволить for..of работать с ним),
нам нужно добавить в объект метод с именем Symbol.iterator
(специальный встроенный Symbol, созданный как раз для этого).

При запуске цикла for..of, вызывается метод Symbol.iterator,
который возвращает объект с методом next() (итератор).

При переборе элементов для каждого элемента вызывается метод next(),
результат которого будет иметь вид {done: Boolean, value: any}.

done == true означает, что выполнение цикла завершёно
*/

range[Symbol.iterator] = function () {
  return {
    current: this.from,
    last: this.to,

    next() {
      if (this.current <= this.last) {
        return { done: false, value: this.current++ };
      } else {
        return { done: true };
      }
    },
  };
};

for (let num of range) {
  alert(num); // 1, затем 2, 3, 4, 5
}

/*
Обратите внимание на ключевую особенность итераторов: разделение ответственности.

- у самого объекта range нет метода next()
- этот метод вызывается у другого объекта (итератора), который создается вызовом range[Symbol.iterator]()

Таким образом, объект итератор отделён от самого итерируемого объекта.

Технически мы можем объединить их и использовать сам range как итератор, чтобы упростить код:
*/

let range_obj = {
  from: 1,
  to: 5,

  [Symbol.iterator]() {
    this.current = this.from;
    return this;
  },

  next() {
    if (this.current <= this.to) {
      return { done: false, value: this.current++ };
    } else {
      return { done: true };
    }
  },
};

/* 
Недостаток такого подхода в том, что теперь мы не можем использовать этот объект
в двух параллельных циклах for..of.

Можно сделать бесконечный итератор. Например, range будет бесконечным при range.to = Infinity
*/

//_ Строка - перебираемый объект

let str = 'Hello';

let iterator = str[Symbol.iterator]();

while (true) {
  let result = iterator.next();
  if (result.done) break;
  alert(result.value); // выводит символы один за другим
}

/* 
Такой способ перебора строки редко бывает необходимым,
но он даёт нам больше контроля над процессом, чем for..of.

Например, мы можем разбить процесс итерации на части:
перебрать немного элементов, затем остановиться,
сделать что-то ещё и потом продолжить
*/

//_ Итерируемые объекты и псевдомассивы

/*
Итерируемые объекты – это объекты, которые реализуют метод
Symbol.iterator, как было описано выше.

Псевдомассивы – это объекты, у которых есть индексы и свойство length,
то есть, они выглядят как массивы. Их нельзя перебрать.
*/

let arrayLike = {
  0: 'Hello',
  1: 'World',
  length: 2,
};

/* 
Что у них общего? И итерируемые объекты, и псевдомассивы – это обычно не массивы,
у них нет методов push, pop и т.д, хотя сам массив является итерируемым объектом.
*/

/* 
Строки, DOM-коллекции (HTMLCollection, NodeList), объект arguments внутри функции,
объекты Map и Set (и функция-генератор, которая создает итерируемый объект?),
а также сами массивы являются и итерируемым объектами и псевдомассивами.

Но итерируемый объект может не быть псевдомассивом.
И наоборот: псевдомассив может не быть итерируемым.

Объекты, являющиеся только итерируемыми: объекты с Symbol.iterator.
Объекты, являющиеся только псевдомассивами: объекты с числовыми индексами и свойством length (не массивы).

WeakMap и WeakSet не являются ни итерируемыми объектами, ни псевдомассивами
*/

//_ Метод Array.from

//' Array.from

/*
Array.from пребразует псевдомассивы или итерируемые объекты в массив.
После преобразования мы можем использовать методы массивов.
*/

// псевдомассив
let array_1 = Array.from(arrayLike); // ['Hello', 'World']

// итерируемый объект
let array_2 = Array.from(range); // [1, 2, 3, 4, 5]

/*
` Array.from(obj[, mapFn, thisArg])

mapFn(опционально) - функция, которая применяется к каждому
элементу перед добавлением в массив.

thisArg - позволяет установить this для этой функции
*/

let arr = Array.from(range, num => num * num); // [1, 4, 9, 16, 25]

/*
В отличие от str.split, этот метод, как и for..of, корректно работает
с суррогатными парами.
*/

//* Итого
/*
Объекты, которые можно использовать в цикле for..of, называются итерируемыми.

Технически итерируемые объекты должны иметь метод Symbol.iterator.

Результат вызова obj[Symbol.iterator] называется итератором.
Он управляет процессом итерации.

Итератор должен иметь метод next(), который возвращает объект
{done: Boolean, value: any}, где done: true сигнализирует
об окончании процесса итерации, в противном случае value – следующее значение.

Метод Symbol.iterator автоматически вызывается циклом for..of,
но можно вызвать его и напрямую.

Встроенные итерируемые объекты, такие как строки или массивы,
также реализуют метод Symbol.iterator.

Строковый итератор корректно работает с суррогатными парами.

Объекты, имеющие индексированные свойства и length, называются псевдомассивами.
Они также могут иметь другие свойства и методы, но у них нет встроенных методов массивов.

Array.from(obj[, mapFn, thisArg]) создаёт настоящий Array из итерируемого объекта
или псевдомассива obj, и затем мы можем применять к нему методы массивов.
Необязательные аргументы mapFn и thisArg позволяют применять функцию
с задаваемым контекстом к каждому элементу.
*/

// Дополнительно

/* 
Создание массива вида [1, 2, 3 ...] из итерируемого объекта немного медленнее,
чем через цикл for:
*/

let array1 = [];

for (let i = 1; i <= 100; i++) {
  array1.push(i);
}

/* 
Полагаю, имеет смысл использовать итерируемые объекты для этих целей
при работе с библиотекой React, так как там не приветствуется мутирование объектов(массивов).

Пример с циклом for в этом случае нам бы пришлось перезаписать так:
*/

let array2 = [];

for (let i = 1; i <= 100; i++) {
  array2 = [...array2, i];
}

/*
Здесь мы перезаписываем переменную в каждой итерации, присваивая ей значение массива,
созданного путем копирования в него элементов array2 и добавления значения i в конец.
Скорость выполнения такого кода при больших значениях i значительно уменьшается
*/

/* 
Ниже приведен пример создания массива из чисел в диапозоне от 1 до 100, которые не делятся
без остатка на 3, 5 и 7:
*/

let my_range = {
  from: 1,
  to: 100,
  filter_arr: [3, 5, 7],

  [Symbol.iterator]() {
    this.current = this.from;
    return this;
  },

  findNextEl(num) {
    if (this.filter_arr.length && this.filter_arr.find(i => num % i === 0)) {
      return this.findNextEl(num + 1);
    }
    return num;
  },

  next() {
    if (this.current <= this.to) {
      this.current = this.findNextEl(this.current);

      if (this.current > this.to) {
        return { done: true };
      }

      return { done: false, value: this.current++ };
    } else {
      return { done: true };
    }
  },
};

range_arr = Array.from(my_range);

/* 
Если нужно создать несколько таких массивов, то лучше использовать классы:
*/

class Sequence {
  constructor(from, to, filterArr) {
    this.from = from;
    this.to = to;
    this.filter_arr = [...filterArr];
  }

  [Symbol.iterator]() {
    this.current = this.from;
    return this;
  }

  get array() {
    return Array.from(new Sequence(this.from, this.to, this.filter_arr));
  }

  findNextEl(num) {
    if (this.filter_arr.length && this.filter_arr.find(i => num % i === 0)) {
      return this.findNextEl(num + 1);
    }
    return num;
  }

  next() {
    if (this.current <= this.to) {
      this.current = this.findNextEl(this.current);

      if (this.current > this.to) {
        return { done: true };
      }

      return { done: false, value: this.current++ };
    } else {
      return { done: true };
    }
  }
}

const rangeArr1 = Array.from(new Sequence(1, 10, [2]));

const rangeArr2 = new Sequence(1, 10, [3]).array;
