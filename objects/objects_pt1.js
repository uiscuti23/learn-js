// * Объекты (object)

/* 
Объекты используются для хранения коллекций различных значений и более сложных сущностей.

Способы создания пустого объекта:
*/

let a = new Object(); // синтаксис "конструктор объекта"
let b = {}; // синтаксис "литерал объекта" (обычно используется этот метод)

/* 
Обычно используется литеральный синтаксис {…}. При этом, мы сразу можем
поместить в объект несколько свойств, отделенных друг от друга запятыми.

Свойство – это пара «ключ: значение», где ключ (имя) – это строка,
а значением может быть что угодно
*/

let user = {
  name: 'John', // под ключом "name" хранится значение "John"
  age: 30, // под ключом "age" хранится значение 30
  'likes birds': true, // имя свойства из нескольких слов должно быть в кавычках
};

alert(user.name); // получение значения
user.isAdmin = true; // добавление
delete user.age; // удаление

/*
Объект, объявленный как константа, может быть изменен.

Дело в том, что объявление const защищает от изменений
только саму переменную user, а не её содержимое.

Определение const выдаст ошибку только если мы
присвоим переменной другое значение: user = ....
*/

const person = {
  name: 'John',
};

person.name = 'Pete';
person.surname = 'Stark';

alert(person.name); // Pete

//_ Квадратные скобки
/* 
Для доступа к свойствам, имена которых состоят из нескольких свойств,
нужно использовать квадратные скобки:
*/

alert(person['likes birds']); // получение значения свойства
person['likes birds'] = true; // присваивание значения свойству
delete person['likes birds']; // удаление свойства

/* 
Если имя свойства хранится в переменной, то можно обратиться
к свойству через него:
*/

let key = 'surname';
obj[key] = 'Carry'; // то же самое, что и obj['surname'] = 'Carry';

/*
Значение переменной key может быть вычислена во время выполнения кода.
И это значение мы можем использовать для доступа к свойству (через [])
*/

//_ Вычисляемые свойства

// Можно присвоить именем свойства значение переменной:

let fruit = 'apple';

let bag = {
  [fruit]: 5,
  [fruit + ' weight']: 20,
};

alert(bag.apple); // 5
alert(bag['apple weight']); // 20

//_ Короткая запись свойств

/* 
При необходимости использовать существующие переменные как значения
для свойств объекта с тем же именем, можно использовать короткую запись свойств:
*/

let title = 'Intel Core 3';

let processor = {
  title,
  price: 8000,
};

alert(processor.title); // 'Intel Core 3'

//_ Нет ограничений на имена свойств

// Мы можем задавать любые имена свойств (кроме __proto__)

let obj = {
  for: 1,
  let: 2,
  return: 3,
};

//_ Проверка существования свойства

// При обращении к свойству, которого нет, возвращается undefined:

let empty = {};

alert(empty.name); // undefined, такого свойства нет в объекте

alert(empty.name === undefined); // true

// Так же, свойство со значением undefined вернет undefined:

empty.value = undefined;

alert(empty.value === undefined); // true, хотя свойство существует

//' Оператор in. (Синтаксис: "key" in object)

/* 
Используется для проверки существования свойства в объекте,
а также в цепочке прототипов данного объекта. Возвращает true, если свойство найдено.

(работает свойств-данных/методов/аксессоров, для свойств с символьными ключами,
перечисляемых и неперечисляемых свойств, в общем для любых свойств)
*/

let about = { name: 'John', age: 30, test: undefined };

// Корректно определяет наличие свойств со значением undefined:

alert('test' in about); // true, about.test существует
alert('blabla' in about); // false, about.blabla не существует

/* 
Подобные ситуации случаются очень редко, так как undefined обычно явно не присваивается.
Для «неизвестных» или «пустых» свойств мы используем значение null
*/

// обычно свойтво toString находится в прототипе объектов

alert('toString' in about); // true

/*
Обычно слева от оператора in должно быть имя свойства в виде строки в кавычках.

Если мы опускаем кавычки, это значит, что мы указываем переменную,
в которой находится имя свойства:
*/

let about_key = 'age';
alert(about_key in about); // true, имя свойства было взято из переменной about_key

//' hasOwn и hasOwnProperty

/* 
Как и оператор in используются для проверки существования свойства в объекте,
Свойства в цепочке прототипов объекта не проверяются.

Object.hasOwn(obj, key), obj.hasOwnProperty(key): возвращают true,
если у obj есть собственное (не унаследованное) свойство с именем key
вне зависимости является ли оно строковым или символьным.

hasOwn имеет преимущество перед hasOwnProperty:
- он может работать с объектами, не имеющими прототип/ы ([[Prototype]] === null):

let foo = Object.create(null);
foo.prop = "exists";

alert(Object.hasOwn(foo, "prop")) // true

- его можно использовать с объектами, которые переопределяют hasOwn,
При переопределении hasOwnProperty объектом, мы не сможем получить доступ
к методу hasOwnProperty прототипа
*/

//_ Перебор свойств объекта

//' Цикл "for..in"

// Используется для перебора свойств объекта

for (let key in object) {
  // тело цикла выполняется для каждого свойства объекта
}

let userInfo = {
  name: 'John',
  age: 30,
  isAdmin: true,
};

for (let key in userInfo) {
  alert(key); // 'name', 'age', 'isAdmin'
  alert(userInfo[key]); // 'John', 30, true
}

// методы Object: keys, values, entries

/*
Следующие методы объекта Object возвращают массив из:

.keys(obj) – ... ключей
.values(obj) – ... значений
.entries(obj) – ... пар [ключ, значение]

Эти методы и цикл "for..in":
- работают только с перечисляемыми свойствами объекта (у которых флаг enumerable: true)
- игнорируют свойства, использующие Symbol(...) в качестве ключей. (символьные свойства).
*/

let user_info = {
  name: 'Alex',
  age: 18,
};

alert(Object.keys(user_info)); // ["name", "age"]
alert(Object.values(user_info)); // ["Alex", 18]
alert(Object.entries(user_info)); // [["name", "Alex"], ["age", 18]]

/* 
Полученные значения мы можем перебрать с помощью цикла 'for..of' или метода forEach,
либо использовать любые другие методы массивов,
так как мы, используя keys, values, entries получаем «реальные» массивы,
а не просто итерируемые объекты
*/

for (let value of Object.values(user_info)) {
  alert(value); // 'Alex', 18
}

// Дополнительно про методы Object и Reflect

/*
Для получения массива всех собственных строковых ключей
(перечисляемых и не перечисляемых) - Object.getOwnPropertyNames(obj)

Для получения массива всех собственных символьных ключей
(перечисляемых и не перечисляемых) - Object.getOwnPropertySymbols.

Также, существует метод Reflect.ownKeys(obj), который возвращает массив всех собственных ключей.
*/

//_ Трансформации объекта, метод Object.fromEntries

/* 
Object.fromEntries(array) создаёт объект из массива пар вида [ключ, значение]
(то есть делает противоположное тому, что делает entries):
*/

let product = Object.fromEntries([
  ['fruit', 'banana'],
  ['price', 45],
]);

// product = { fruit: 'banana', price: 45 }

/* 
У объектов нет множества методов, которые есть в массивах, например map, filter и других.

Если мы хотели бы их применить,
то можно использовать Object.entries с последующим вызовом Object.fromEntries:

- вызов Object.entries(obj) возвращает массив пар ключ/значение для obj
- на нём вызываем методы массива, например, map
- при помощи Object.fromEntries(array) преобразуем результат обратно в объект
*/

let prices = {
  banana: 1,
  orange: 2,
  meat: 4,
};

let doublePrices = Object.fromEntries(
  Object.entries(prices).map(([key, value]) => [key, value * 2])
);

// doublePrices = { banana: 2, orange: 4, meat: 8 }

// Так же можно воспользоваться циклом 'for..in':

for (let key in prices) {
  prices[key] = prices[key] * 2;
}

//_ Упорядочение свойств объекта

/*
Порядок свойств в объекте не имеет большой роли.

Обычно свойства располагаются в порядке создания.

Но свойства с целочисленными ключами, например, '1'
(не путать с '+1', '1.2'), сортируются по возрастанию
и будут идти первыми в объекте.

Чтобы избежать этого можно к ним добавить "+" первым символом,
например, '1' запишем как '+1'
*/
