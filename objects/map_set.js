// * Map

/*
Map – это коллекция ключ/значение, как и Object.
Но основное отличие в том, что Map позволяет использовать
ключи любого типа.
*/

// Методы и свойства

/*
new Map() – создаёт коллекцию.

map.set(key, value) – записывает по ключу key значение value.

map.get(key) – возвращает значение по ключу или undefined,
если ключ key отсутствует.

map.has(key) – возвращает true, если ключ key присутствует в коллекции,
иначе false.

map.delete(key) – удаляет элемент по ключу key.

map.clear() – очищает коллекцию от всех элементов.

map.size – возвращает текущее количество элементов.
*/

let map = new Map();

map.set('1', 'str1'); // строка в качестве ключа
map.set(1, 'num1'); // цифра как ключ
map.set(true, 'bool1'); // булево значение как ключ

// Map сохраняет тип ключей, так что в этом случае сохранится 2 разных значения:
alert(map.get(1)); // "num1"
alert(map.get('1')); // "str1"

alert(map.size); // 3

/*
map[key] это не совсем правильный способ использования Map
*/

// Map может использовать объекты в качестве ключей

let john = { name: 'John' };

// давайте сохраним количество посещений для каждого пользователя
let visits = new Map();

// объект john - это ключ для значения в объекте Map
visits.set(john, 123);

alert(visits.get(john)); // 123

/*
Чтобы сравнивать ключи, объект Map использует алгоритм SameValueZero.
Это почти такое же сравнение, что и ===, с той лишь разницей,
что NaN считается равным NaN.

Так что NaN также может использоваться в качестве ключа.
Этот алгоритм не может быть заменён или модифицирован.
*/

/*
Каждый вызов map.set возвращает объект map, так что мы можем
объединить вызовы в цепочку:
*/
map.set('1', 'str1').set(1, 'num1').set(true, 'bool1');

//_ Перебор Map

/*
map.keys() – возвращает итерируемый объект по ключам.

map.values() – возвращает итерируемый объект по значениям.

map.entries() – возвращает итерируемый объект по парам вида
[ключ, значение], этот вариант используется по умолчанию в for..of.

При создании Map мы можем указать массив (или другой итерируемый объект)
с парами ключ-значение для инициализации:
*/

let recipeMap = new Map([
  ['огурец', 500],
  ['помидор', 350],
  ['лук', 50],
]);

// перебор по ключам (овощи)
for (let vegetable of recipeMap.keys()) {
  alert(vegetable); // 'огурец', 'помидор', 'лук'
}

// перебор по значениям (числа)
for (let amount of recipeMap.values()) {
  alert(amount); // 500, 350, 50
}

// перебор по элементам в формате [ключ, значение]
for (let entry of recipeMap) {
  // то же самое, что и recipeMap.entries()
  alert(entry); // ['огурец', 500] (и так далее)
}

/*
В отличие от обычных объектов Object, в Map перебор происходит
в том же порядке, в каком происходило добавление элементов (используется порядок вставки)
*/

// Map имеет встроенный метод forEach, схожий со встроенным методом массивов Array:

// выполняем функцию для каждой пары (ключ, значение)
recipeMap.forEach((value, key, map) => {
  alert(`${key}: ${value}`); // 'огурец: 500' и так далее
});

//_ Получение Map из объекта (Object.entries)

// Метод Object.entries(obj), получив объект возвращает массив пар ключ-значение

let obj = {
  name: 'John',
  age: 30,
};

let map1 = new Map(Object.entries(obj)); // тоже самое, что:

/*
let map1 = new Map([
	['name', 'John'],
	['age', 30],
])

Здесь Object.entries возвращает массив пар
ключ-значение: [ ["name","John"], ["age", 30] ]
*/

alert(map1.get('name')); // 'John'

//_ Получение объекта из Map (Object.fromEntries)

// Метод Object.fromEntries, получив массив пар вида [ключ, значение], создаёт из них объект

// Получение объекта из массива пар вида [ключ, значение]:

let pricesArr = [
  ['banana', 1],
  ['orange', 2],
  ['meat', 4],
];

let prices = Object.fromEntries(pricesArr);

alert(prices); // { banana: 1, orange: 2, meat: 4 }
alert(prices.orange); // 2

// Получение объекта из Map:

let map2 = new Map();

map2.set('banana', 1);
map2.set('orange', 2);
map2.set('meat', 4);

let object = Object.fromEntries(map2.entries()); // создаём обычный объект (*)

alert(object); // { banana: 1, orange: 2, meat: 4 }
alert(object.orange); // 2

/*
Перебор map возвращает пары ключ/значение, так же, как и map.entries(). 

Так как Object.fromEntries ожидает перебираемый объект в качестве аргумента,
(не обязательно массив), мы бы могли переписать строку (*) короче:
*/

let object1 = Object.fromEntries(map); // убрали .entries()

// * Set

/*
Объект Set представляет собой коллекцию значений (без ключей),
где значения не повторяются.

Методы Set:

new Set(iterable) – создаёт Set, и если в качестве аргумента
был предоставлен итерируемый объект (обычно это массив),
то копирует его значения в новый Set.

set.add(value) – добавляет значение (если оно уже есть, то ничего не делает),
возвращает тот же объект set.

set.delete(value) – удаляет значение, возвращает true,
если value было в множестве на момент вызова, иначе false.

set.has(value) – возвращает true, если значение присутствует
в множестве, иначе false.

set.clear() – удаляет все имеющиеся значения.

set.size – возвращает количество элементов в множестве.
*/

/* 
При повторных вызовах set.add() с одним и тем же значением ничего не происходит,
за счёт этого как раз и получается, что каждое значение появляется один раз.

Например, мы ожидаем посетителей, и нам необходимо составить их список.
Но повторные визиты не должны приводить к дубликатам.
Каждый посетитель должен появиться в списке только один раз.
*/

let set = new Set();

let alex = { name: 'Alex' };
let pete = { name: 'Pete' };
let mary = { name: 'Mary' };

// считаем гостей, некоторые приходят несколько раз
set.add(alex);
set.add(pete);
set.add(mary);
set.add(alex);
set.add(mary);

// set хранит только 3 уникальных значения
alert(set.size); // 3

for (let user of set) {
  alert(user.name); // 'Alex' (потом 'Pete' и 'Mary')
}

/* 
Альтернативой множеству Set может выступать массив для хранения гостей
и дополнительный код для проверки уже имеющегося элемента с помощью arr.find.

Но в этом случае будет хуже производительность, потому что arr.find
проходит весь массив для проверки наличия элемента.

Множество Set лучше оптимизировано для добавлений,
оно автоматически проверяет на уникальность.
*/

//_ Перебор объекта Set

let fruits = new Set(['апельсин', 'яблоко', 'банан']);

for (let value of fruits) alert(value);

// то же самое с forEach:
fruits.forEach((value, valueAgain, set) => {
  alert(value);
});

/*
value, valueAgain - одно и то же значение. Так сделано для
совместимости с Map
*/

/*
Set имеет те же встроенные методы, что и Map:

set.values() – возвращает перебираемый объект для значений.

set.keys() – то же самое, что и set.values(), присутствует
для обратной совместимости с Map.

set.entries() – возвращает перебираемый объект для пар вида
[значение, значение], присутствует для обратной совместимости с Map.
*/

/* 
Перебор Map и Set всегда осуществляется в порядке добавления элементов,
так что нельзя сказать, что это – неупорядоченные коллекции,
но поменять порядок элементов или получить элемент напрямую по его номеру нельзя.
*/

//_ Получение Set из массива

let arr1 = ['апельсин', 'яблоко', 'банан'];
let set1 = new Set(arr1);

//_ Получение массива из Set

let set2 = new Set(['апельсин', 'яблоко', 'банан']);
let arr2 = [...set2.values()]; // или let arr2 = [...set2.keys()]
let arr_2 = Array.from(set2);

//* WeakMap

/* 
Движок JavaScript хранит значения в памяти до тех пор, пока они достижимы
(то есть, эти значения могут быть использованы).

(Подробнее этот механизм описан в теме: "сборка мусора".
Расположение: learn -> addition -> garbage_collection.js)
*/

let arnold = { name: 'Arnold' }; // объект доступен, переменная arnold — это ссылка на него

arnold = null; // перепишем ссылку (объект будет удалён из памяти)

/* 
Обычно свойства объекта, элементы массива или другой структуры данных
считаются достижимыми и сохраняются в памяти до тех пор,
пока эта структура данных содержится в памяти.

Например, если мы поместим объект в массив, то до тех пор,
пока массив существует, объект также будет существовать в памяти,
несмотря на то, что других ссылок на него нет:
*/

let carl = { name: 'Carl' };

let array = [carl];

carl = null; // перезаписываем ссылку на объект

alert(array[0]); // объект carl хранится в массиве, поэтому он не будет удалён сборщиком мусора

/* 
Аналогично, если мы используем объект как ключ в Map, то до тех пор,
пока существует Map, также будет существовать и этот объект.

Он занимает место в памяти и не может быть удалён сборщиком мусора
*/

let felix = { name: 'Felix' };

let map_1 = new Map();
map_1.set(felix, '...');

felix = null; // перезаписываем ссылку на объект

alert(map_1.keys()); // объект { name: 'Felix' } сохранён внутри объекта `Map`

/* 
WeakMap – принципиально другая структура в этом аспекте.
Она не предотвращает удаление объектов сборщиком мусора,
когда эти объекты выступают в качестве ключей.
*/

/*
WeakMap – это Map-подобная коллекция, позволяющая использовать
в качестве ключей только объекты, и автоматически удаляющая их
вместе с соответствующими значениями, как только они становятся
недостижимыми иными путями.

Мы не знаем, в какой момент произойдёт эта очистка,
решение принимает движок JavaScript.

WeakMap не поддерживает перебор и методы keys(), values(),
entries(), так что нет способа взять все ключи или значения из неё.

Присутствуют только следующие методы:

weakMap.set(key, value) - установить ключ и значение
weakMap.get(key) - получить значение по ключу
weakMap.delete(key) - удалить значение по ключу
weakMap.has(key) - узнать наличие значения по ключу

отсутствуют методы clear() и size
*/

let james = { name: 'James' };

let weakMap = new WeakMap();
weakMap.set(james, '...');

james = null;

alert(weakMap); // weakMap {empty}, объект james удалён из памяти!

// нельзя использовать строку в качестве ключа
weakMap.set('test', 'Whoops'); // Ошибка, потому что "test" не объект

// Но для чего же нам нужна такая структура данных?

//_ В основном WeakMap используется как дополнительное хранилище данных

/* 
Если мы работаем с объектом, который «принадлежит» другому коду
может быть даже сторонней библиотеке, и хотим сохранить у себя
какие-то данные для него, которые должны существовать
лишь пока существует этот объект, то WeakMap – как раз то, что нужно.

Мы кладём эти данные в WeakMap, используя объект как ключ,
и когда сборщик мусора удалит объекты из памяти,
ассоциированные с ними данные тоже автоматически исчезнут.
*/

weakMap.set(john, 'секретные документы');
// если john = null, "секретные документы" будут автоматически уничтожены

//_ Пример реализации счётчика посещений

/* 
Предположим, у нас есть код, который ведёт учёт посещений для пользователей.
Информация хранится в коллекции WeakMap: объект, представляющий пользователя,
является ключом, а количество визитов – значением.

Когда пользователь нас покидает (его объект удаляется сборщиком мусора),
то больше нет смысла хранить соответствующий счётчик посещений.
*/

// 📁 visitsCount.js
let user_visits = new WeakMap(); // map: пользователь => число визитов

// увеличиваем счётчик
function countUser(user) {
  let val = user_visits.get(user) || 0;
  user_visits.set(user, val + 1);
}

// 📁 main.js
let henry = { name: 'Henry' };

countUser(henry); //ведём подсчёт посещений
countUser(henry);

alert(user_visits); // { name: "Henry" } => 2
alert(user_visits.get(henry)); // 2

// пользователь покинул нас
henry = null;

alert(user_visits.get(henry)); // undefined

/*
Нам не нужно очищать user_visits при удалении объекта пользователя,
коллекция не будет бесконечно расти.

После того, как объект henry стал недостижим другими способами,
кроме как через WeakMap, он удаляется из памяти вместе
с информацией по такому ключу из WeakMap.
*/

//_ Применение для кеширования

/* 
Другая частая сфера применения – это кеширование, когда результат вызова функции
должен где-то запоминаться («кешироваться») для того, чтобы дальнейшие её вызовы
на том же объекте могли просто брать уже готовый результат, повторно используя его.
*/

// 📁 cache.js
let cache = new WeakMap();

// вычисляем и запоминаем результат
function process(obj) {
  if (!cache.has(obj)) {
    let result = /* вычисляем результат для объекта */ obj;
    cache.set(obj, result);
  }
  return cache.get(obj);
}

// 📁 main.js
let object_1 = {
  /* какой-то объект */
};

let result1 = process(object_1);
let result2 = process(object_1);

// ...позже, когда объект больше не нужен:
object_1 = null;

/* 
Нет возможности получить cache.size, так как это WeakMap,
но он равен 0 или скоро будет равен 0.
Когда сборщик мусора удаляет object_1, связанные с ним данные из кеша тоже удаляются
*/

//* WeakSet

/*
Коллекция WeakSet ведёт себя похоже:

- Она аналогична Set, но мы можем добавлять в WeakSet только объекты (не примитивные значения).

- Объект присутствует в множестве только до тех пор, пока доступен где-то ещё.

- Как и Set, она поддерживает add, delete и has, но не clear(), size и не является перебираемой
(не поддерживаются методы keys(), values() и entries())
*/

// Пример учёта лиц, посетивших сайт:

let visitedSet = new WeakSet();

let gerald = { name: 'Gerald' };
let scott = { name: 'Scott' };
let jesse = { name: 'Jesse' };

visitedSet.add(gerald); // Gerald заходил к нам
visitedSet.add(scott); // потом scott
visitedSet.add(gerald); // Gerald снова

// visitedSet сейчас содержит двух пользователей

// проверим, заходил ли Gerald?
alert(visitedSet.has(gerald)); // true

// проверим, заходила ли Jesse?
alert(visitedSet.has(jesse)); // false

gerald = null;
alert(visitedSet.has(gerald)); // false

/* 
Структура данных visitedSet будет очищена автоматически
(объект gerald будет удалён из visitedSet)
*/

/*
В WeakMap и WeakSet нельзя перебирать или взять все содержимое, их задача -
быть дополнительным хранилищем данных для объектов, управляемых из каких-то других мест в коде
*/

// * Итого

/* 
Map – коллекция пар ключ-значение.

Методы и свойства:

new Map([iterable]) – создаёт коллекцию, можно указать перебираемый объект
(обычно массив) из пар [ключ,значение] для инициализации.

map.set(key, value) – записывает по ключу key значение value.
map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
map.delete(key) – удаляет элемент по ключу key.
map.clear() – очищает коллекцию от всех элементов.
map.size – возвращает текущее количество элементов.

Отличия от обычного объекта Object:

- что угодно может быть ключом, в том числе и объекты.
- есть дополнительные методы, свойство size.


Set – коллекция уникальных значений, так называемое «множество».

Методы и свойства:
new Set(iterable) – создаёт Set, можно указать перебираемый объект со значениями для инициализации.

set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
set.delete(value) – удаляет значение, возвращает true если value было в множестве на момент вызова, иначе false.
set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.
set.clear() – удаляет все имеющиеся значения.
set.size – возвращает количество элементов в множестве.


Перебор Map и Set всегда осуществляется в порядке добавления элементов,
так что нельзя сказать, что это – неупорядоченные коллекции,
но поменять порядок элементов или получить элемент напрямую по его номеру нельзя.

Map и Set поддерживают перебор (методы keys(), values(), entries(), forEach, цикл for..of)


Для получения Map из объекта используйте метод Object.entries(obj).

Для получения объекта из Map или из массива пар вида [ключ, значение]
используйте метод Object.fromEntries.

Для получения Set из массива передайте массив как аргумент в new Set(...).

Для получения массива из Set скопируйте в пустой массив все элементы Set,
вызвав метод values() или keys()
*/

/* 
WeakMap – это Map-подобная коллекция, позволяющая использовать в качестве ключей только объекты,
и автоматически удаляющая их вместе с соответствующими значениями,
как только они становятся недостижимыми иными путями.

WeakSet – это Set-подобная коллекция, которая хранит только объекты и удаляет их,
как только они становятся недостижимыми иными путями.

Обе этих структуры данных не поддерживают методы и свойства,
работающие со всем содержимым сразу или возвращающие информацию о размере коллекции.
Возможны только операции на отдельном элементе коллекции.

WeakMap и WeakSet используются как вспомогательные структуры данных
в дополнение к «основному» месту хранения объекта.
Если объект удаляется из основного хранилища и нигде не используется,
кроме как в качестве ключа в WeakMap или в WeakSet, то он будет удалён автоматически.

Методы WeakMap:

weakMap.set(key, value) - установить ключ и значение
weakMap.get(key) - получить значение по ключу
weakMap.delete(key) - удалить значение по ключу
weakMap.has(key) - узнать наличие значения по ключу

отсутствуют методы clear() и size

Методы WeakSet:

add, delete и has, но не clear() и size

WeakMap и WeakSet не поддерживают перебор и методы keys(), values(), entries()
*/
