// * Дата и время

/* 
Date - это встроенный объект. Он содержит дату и время,
а также предоставляет методы управления ими.

Например, его можно использовать для хранения времени создания/изменения,
для измерения времени или просто для вывода текущей даты.
*/

//_ Создание

// 1. Текущее время - new Date()

let now = new Date(); // текущие дата и время

// 2. new Date (milliseconds) или new Date(timestamp)

/*
Время, равное количеству миллисекунд (тысячная доля секунды),
прошедших с 1 января 1970 года UTC+0. */

// 0 соответствует 01.01.1970 UTC+0
let Jan01_1970 = new Date(0);
alert(Jan01_1970);

// теперь добавим 24 часа и получим 02.01.1970 UTC+0
let Jan02_1970 = new Date(24 * 3600 * 1000);
alert(Jan02_1970);

// 31 декабря 1969 года
let Dec31_1969 = new Date(-24 * 3600 * 1000);
alert(Dec31_1969);

/* 
Целое число, представляющее собой количество миллисекунд,
прошедших с начала 1970 года, называется таймстамп (англ. timestamp).
*/

// 3. new Date(datestring)

let dateStr = new Date('2017-01-26');

/*
Время не указано, значит она будет по умолчанию становится в полночь по Гринвичу и
меняется в соответствии с часовым поясом места выполнения кода.

Так что в результате можно получить, к примеру:
Thu Jan 26 2017 11:00:00 GMT+1100 (восточно-австралийское время) или
Wed Jan 25 2017 16:00:00 GMT-0800 (тихоокеанское время)
*/

// 4. new Date(year, month, date, hours, minutes, seconds, ms)

/*
Создаёт объект Date с заданными компонентами в местном часовом поясе.
Два первых аргумента обязательные.

- year должен состоять из четырёх цифр.
Для совместимости также принимаются 2 цифры и рассматриваются как 19xx (98 то же самое, что 1998)

- month начинается с 0 (январь) по 11 (декабрь).

- параметр date здесь представляет собой день месяца.
Если параметр не задан, то принимается значение 1.

- если параметры hours/minutes/seconds/ms отсутствуют,
их значением становится 0.
*/

new Date(2011, 0, 1, 0, 0, 0, 0); // 1 Jan 2011, 00:00:00
new Date(2011, 0, 1); // то же самое
new Date(2011, 0); // то же самое

// Максимальная точность – 1 мс (до 1/1000 секунды):
let Jan01_2011 = new Date(2011, 0, 1, 2, 3, 4, 567);
alert(Jan01_2011); // 1.01.2011, 02:03:04.567

//_ Получение компонентов даты

/*
Все нижеперечисленные методы возвращают значения
в соответствии с местным часовым поясом:

getFullYear() - получить год (4 цифры). (Не используйте getYear()).

getMonth() - получить месяц, от 0 до 11.

getDate() - получить день месяца, от 1 до 31, что несколько
противоречит названию метода.

getHours(), getMinutes(), getSeconds(), getMilliseconds() -
получить, соответственно, часы, минуты, секунды или миллисекунды.

getDay() - вернуть день недели от 0 (воскресенье) до 6 (суббота).
Несмотря на то, что в ряде стран за первый день недели принят
понедельник, в JavaScript начало недели приходится на воскресенье.
*/

/*
Все вышеперечисленные методы возвращают значения в соответствии с местным часовым поясом!

Существуют и их UTC-варианты, возвращающие день, месяц, год для временной зоны UTC+0:
getUTCFullYear(), getUTCMonth(), ... getUTCDay()
*/

let nowDate = new Date(); // текущая дата

alert(nowDate.getHours()); // час в вашем текущем часовом поясе
alert(nowDate.getUTCHours()); // час в часовом поясе UTC+0 (лондонское время без перехода на летнее время)

/*
Помимо вышеприведённых методов, существуют два особых метода без UTC-варианта:

getTime()
Для заданной даты возвращает таймстамп – количество миллисекунд,
прошедших с 1 января 1970 года UTC+0.

getTimezoneOffset()
Возвращает разницу в минутах между UTC и местным часовым поясом.
(если вы в часовом поясе UTC-1, то выводится 60, если в UTC+3, выводится -180)
*/

alert(new Date().getTimezoneOffset());

//_ Установка компонентов даты

/*
Следующие методы позволяют установить компоненты даты и времени:

setFullYear(year, [month], [date])
setMonth(month, [date])
setDate(date)
setHours(hour, [min], [sec], [ms])
setMinutes(min, [sec], [ms])
setSeconds(sec, [ms])
setMilliseconds(ms)
setTime(milliseconds) (устанавливает дату в виде целого
количества миллисекунд, прошедших с 01.01.1970 UTC)

У всех этих методов, кроме setTime(), есть UTC-вариант, например: setUTCHours().
*/

let today = new Date();

today.setHours(0);
alert(today); // выводится сегодняшняя дата, но значение часа будет 0

today.setHours(0, 0, 0, 0);
alert(today); // всё ещё выводится сегодняшняя дата, но время будет ровно 00:00:00

//_ Автоисправление даты

/* 
Можно устанавливать компоненты даты вне обычного диапазона значений,
а объект сам себя исправит */

let date1 = new Date(2013, 0, 32); // 32 Jan 2013 ?!?
alert(date1); // ...1st Feb 2013!

/*
Неправильные компоненты даты автоматически распределяются по остальным.

Предположим, нам требуется увеличить дату «28 февраля 2016» на два дня.

Объект Date автоматически правильно поставит дату в зависимости
високосный ли год или нет:
*/
let date2 = new Date(2016, 1, 28);
date2.setDate(date2.getDate() + 2);

alert(date); // 1 Mar 2016

/*
Эту возможность часто используют, чтобы получить дату по прошествии
заданного отрезка времени. Например, получим дату «спустя 70 секунд
с текущего момента»:
*/

let date3 = new Date();
date3.setSeconds(date3.getSeconds() + 70);

alert(date3); // выводит правильную дату

// Также можно установить нулевые или даже отрицательные значения:

let date4 = new Date(2016, 0, 2); // 2 Jan 2016

date4.setDate(0); // первый день месяца -- это 1, так что выводится последнее число предыдущего месяца
alert(date4); // 31 Dec 2015

//_ Преобразование к числу, разность дат

/* 
Если объект Date преобразовать в число,
то получим таймстамп по аналогии с date.getTime():
*/

let date_1 = new Date();
alert(+date_1); // количество миллисекунд, то же самое, что date.getTime()

/* 
Даты можно вычитать, в результате получаем разность в миллисекундах.
Этот приём можно использовать для измерения времени:
*/

let start = new Date(); // начинаем отсчёт времени

// выполняем некоторые действия
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let end = new Date(); // заканчиваем отсчёт времени

alert(`Цикл отработал за ${end - start} миллисекунд`);

//_ Date.now()

/* 
Для получения текущего времени в формате таймстампа, используйте метод Date.now().

Семантически он эквивалентен new Date().getTime(),
однако метод не создаёт промежуточный объект Date.

Так что этот способ работает быстрее и не нагружает сборщик мусора
*/

let startTime = Date.now(); // количество миллисекунд с 1 января 1970 года

// выполняем некоторые действия
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let endTime = Date.now(); // заканчиваем отсчёт времени

alert(`Цикл отработал за ${end - start} миллисекунд`); // вычитаются числа, а не даты

//_ Разбор строки с датой

/*
Метод Date.parse(str) считывает дату из строки.

Формат строки должен быть следующим: YYYY-MM-DDTHH:mm:ss.sssZ, где:

- YYYY-MM-DD – это дата: год-месяц-день.

- Символ "T" используется в качестве разделителя.

- HH:mm:ss.sss – время: часы, минуты, секунды и миллисекунды.

- Необязательная часть 'Z' обозначает часовой пояс в формате +-hh:mm.
Если указать просто букву Z, то получим UTC+0.

Возможны и более короткие варианты, например, YYYY-MM-DD или YYYY-MM, или даже YYYY.

Вызов Date.parse(str) обрабатывает строку в заданном формате и возвращает таймстамп
(количество миллисекунд с 1 января 1970 года UTC+0).

Если формат неправильный, возвращается NaN.
*/

let ms = Date.parse('2012-01-26T13:51:50.417-07:00');

alert(ms); // 1327611110417 (таймстамп)

// Можно тут же создать объект new Date из таймстампа:

let date = new Date(Date.parse('2012-01-26T13:51:50.417-07:00'));

// * итог

/*
- Дата и время в JavaScript представлены объектом Date.
Нельзя создать «только дату» или «только время»: объекты Date всегда содержат и то, и другое.

- Счёт месяцев начинается с нуля (да, январь – это нулевой месяц).

- Дни недели в getDay() также отсчитываются с нуля
что соответствует воскресенью.

- Объект Date самостоятельно корректируется при введении значений, выходящих за рамки допустимых.
Это полезно для сложения/вычитания дней/месяцев/недель.

- Даты можно вычитать, и разность возвращается в миллисекундах.
Так происходит, потому что при преобразовании в число объект Date становится таймстампом.

- Используйте Date.now() для быстрого получения текущего времени в формате таймстампа.

Учтите, что, в отличие от некоторых других систем, в JavaScript таймстамп в миллисекундах,
а не в секундах.


В браузерах есть метод performance.now(), возвращающий количество миллисекунд
с начала загрузки страницы с точностью до микросекунд (3 цифры после точки):
*/

alert(`Загрузка началась ${performance.now()}мс назад`);

// Получаем что-то вроде: "Загрузка началась 34731.26000000001мс назад"

// .26 –- это микросекунды (260 микросекунд)
// корректными являются только первые три цифры после точки,
// а остальные -- это ошибка точности

// ------------------------------------------------------------

// * Более понятное объяснение этой темы, если есть затруднения

/* 
Имеются 4 способа создать объект Date, отличаются они в первую очередь аргументами.
*/

let date_now = new Date(); // текущие дата и время, для местного времени

let date_by_nums = new Date(2017, 0, 1, 10, 20, 0, 0); // устанавливаемая дата, для местного времени

let date_by_msec = new Date(0); // устанавливаемая дата для Лондона (в ms), скорректированная на местное время

let date_by_str = new Date('2016-01-24T00:51:50.417+02:00'); // устанавливаемые дата и часовой пояс
// для Лондона, если в конце есть +00:00 или Z или для другого часового пояса (+-hh:mm), скорректированные на местное время,
// или для местного времени, если в конце их нет (нет +-hh:mm и Z)

// если дата принимает неполную строку: new Date('2016-01-24') - устанавливаемая дата для Лондона, скорректированная на местное время

/* 
3й способ и 4й (за исключением случая, создания как '2016-01-24T00:51:50.417') создания даты устанавливают время,
которое не зависит от часового пояса, в котором была создана дата.
*/

/* 
Все эти объявленные переменные выведут при логировании строковое представление даты вида:
'Fri Feb 23 2024 02:56:39 GMT+0500 (Екатеринбург, стандартное время)'.

Способы получения их в виде таймстампа: +var, Number(var), var.getTime(),
а также метод Date.parse(var), который все же лучше использовать
для получения таймстампа из строки вида '2016-01-24T00:51:50.417+05:00'.

Для получения текущего времени в формате таймстампа, используйте метод Date.now(),
а не new Date().getTime() и тд, так как в этом случае не создается промежуточный объект Date.

Для получения разности дат в формате таймстампа не обязательно их преобразовывать по отдельности,
они неявно преобразуются сами.

Для получения разницы в минутах между UTC+0 (время по Лондону) и местным часовым поясом
используем метод getTimezoneOffset(). Его можно вызвать как метод для любой переменной,
содержащий дату.

Для получения даты в формате строки из таймстампа вызываем new Date(timestamp)
*/

/* 
При создании даты способом, использовавшимся при создании переменной date_by_nums (пример выше),
можно устанавливать компоненты даты вне обычного диапазона значений (больше максимального значения,
либо отрицательные), ошибки не будет, время корректно исправится.

Не забываем, что счет месяцев начинается с нуля (январь - нулевой месяц),
как счет дней недели (вск - нулевой день недели).
*/

/* 
Для получения/изменения отдельных компонентов даты (год, месяц и тд) вызываем методы get.../set... .
Мы знаем, что даты, вне зависимости от способа создания указываются (в некоторых случаях корректируются) для местного времени.

Если мы хотим получить время для временной зоны UTC+0 (время по Лондону),
в зависимости от разницы временных зон, вызываем методы getUTC.../setUTC... .

Например у нас есть время по Екатеринбургу(UTC+5): 1 янв 2010 10:00.
То же время по UTC+0 будет: 1 янв 2010 05:00.
*/

// Дополнительно

//_ Бенчмаркинг

/* 
Вычисления, замеряющие производительность, также называют «бенчмарками» (benchmark).

Напишем функционал сравнения скорости выполнения 2-х функций:
*/

const diffSubtract = (date1, date2) => date2 - date1;

const diffGetTime = (date1, date2) => date2.getTime() - date1.getTime();

/* 
Обе функции делают буквально одно и то же, только одна использует явный метод date.getTime()
для получения даты в миллисекундах, а другая полагается на преобразование даты в число.
Результат их работы всегда один и тот же.
*/

/* 
1. Для начала можно запустить их много раз подряд и засечь разницу.
В нашем случае функции очень простые, так что потребуется хотя бы 100000 повторений.

2. Для получения наиболее достоверных результатов тестирования производительности
весь набор бенчмарков нужно запускать по нескольку раз.

3. Современные интерпретаторы JavaScript начинают применять продвинутые оптимизации
только к «горячему коду», выполняющемуся несколько раз (незачем оптимизировать то,
что редко выполняется). Нелишним будет добавить предварительный запуск для «разогрева»
*/

function bench(f) {
  let date1 = new Date(0);
  let date2 = new Date();

  let start = Date.now();
  for (let i = 0; i < 100000; i++) f(date1, date2); // (1)
  return Date.now() - start;
}

let time1 = 0;
let time2 = 0;

// (3) добавляем для "разогрева" перед основным циклом
bench(diffSubtract);
bench(diffGetTime);

// (2) bench(diffSubtract) и bench(diffGetTime) поочерёдно запускаются 10 раз
for (let i = 0; i < 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}

alert('Итоговое время diffSubtract: ' + time1);
alert('Итоговое время diffGetTime: ' + time2);
