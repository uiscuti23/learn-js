// * Операторы

// Операнд - это то к чему применяется оператор, их ещё называют аргументами.

// Унарным считается оператор, который применён только одному операнду:
let cash = -800; // число 800 - операнд

// Бинарным называется операторы которые применяются к двум операндам:
let diff = 30 - 6;

/* 
Формально, мы говорим о двух разных операторах, использующих один символ:
оператор отрицания (унарный оператор, который обращает знак)
и оператор вычитания (бинарный оператор, который вычитает одно число из другого)
*/

// * Математические операторы

// В JS поддерживаются следующие математические операторы:

x = 5 + 8; // сложение
x = 9 - 5; // вычитание
x = 2 * 3; // умножение
x = 10 / 2; // деление

x = 11 % 3; // взятие остатка от деления
x = 5 ** 3; // возведение в степень

x = +4; // унарный плюс
x = -5; // унарный минус

/* 
Все математические операторы всегда преобразуют операнды в числа,
а затем выполняют вычисления:
*/

alert(6 - '2'); // 4
alert('6' / '2'); // 3
alert('100px' * 4); // NaN
alert(false - true); // -1

//_ Бинарный плюс

/*
Исключением из этого правила является бинарный плюс - он умеет складывать строки:
*/

let town = 'New' + ' York';
alert(town); // 'New York'

// если один из его операндов строка, то второй будет также преобразован в строку:

alert(300 + ' Spartans'); // '300 Spartans'
alert(true + 'false'); // 'truefalse'
alert(2 + 2 + '1'); // '41'

// если среди его операндов нет строк, то они преобразуются в числа:

alert(null + true); // 1

//_ Унарный плюс и минус

// унарный минус меняет знак числа на противоположный

let y = 4;
alert(-y); // -4

// унарный плюс ничего не делает с числами,
// но если операнд не является числом, он преобразуется в число:

let int = 7;
let digit = -2;

alert(+int); // 7
alert(+digit); // -2 (не влияет на числа)

alert(+true); // 1
alert(+''); // 0
alert(+'12'); // 12 (то же самое, что и Number('12'), только короче)

let apples = '2';
let oranges = '3';

alert(apples + oranges); // '23' (бинарный плюс сложит строки)
alert(+apples + +oranges); // 5 (преобразуем строки в числа и складываем)

alert(Number(apples) + Number(oranges)); // 5 (такой же результат, как с унарным +)

/*
Если в выражении есть несколько операторов – порядок их выполнения определяется приоритетом, 
или, другими словами, существует определённый порядок выполнения операторов:

https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence
*/

// * Оператор присвоения

// оператор присвоения возвращает значение:

let a = 1 + 2;
let b = 2;
let с = 8 - (a = b + 3); // 8 - (a = 5) = 3

// Присваивание по цепочке

let one = (two = three = 2 + 2);

/*
Такое присваивание работает справа налево. Сначала вычисляется самое правое выражение 2 + 2,
и затем результат присваивается переменным слева: three, two и one.
В конце у всех переменных будет одно значение.
*/

// Сокращенная запись с присвоением

users += 3; // соответствует записи: users = users + 3
users *= 2; // соответствует записи: users = users * 2

//* Инкремент/декремент

// Инкремент ++ увеличивает переменную на 1:

let counter = 2;
counter++;
alert(counter); // 3

// Декремент -- уменьшает переменную на 1:

let count = 2;
count--;
alert(count); // 1

/*
Инкремент/декремент можно применить только к переменной.
Попытка использовать его на значении приведёт к ошибке.
*/
// alert(5++); //  SyntaxError

// Операторы ++ и -- могут быть расположены не только после, но и до переменной:

let some = 0;

some++; // постфиксная форма
++some; // префиксная форма
alert(some); // 2

/*
Оба этих оператора делают одно и то же: увеличивают some на 1,
но возращают разные значения:
*/

// возвращается старое значение (до увеличения/уменьшения числа)

let number = 0;
alert(number++); // 0

// возвращается новое значение

let num = 0;
alert(++num); // 1

// Приоритет инкремента/дикремента выше, чем у большинства арифметических операторов.

let total = 1;
let val = 2 * total++;
alert(val); // 2

let totalizer = 1;
let value = 2 * ++totalizer;
alert(value); // 4

// * Оператор запятая

/*
Предоставляет возможность вычислять несколько выражений, разделяя их запятой.
Каждое выражение выполняется, но возвращается результат только последнего.
*/
// имеют низкий приоритет, ниже =, поэтому заключаются в скобки

let d = (1 + 2, 3 + 4);
alert(d); // 7

/*
иногда его используют в составе более сложных конструкций,
чтобы сделать несколько действий в одной строке.
*/
for (a = 1, b = 3, c = a * b; a < 10; a++) {
  // ...
}

// * Побитовые операторы (используются очень редко)

// * Операторы сравнения

let u, q;

u > q; // больше
u < q; // меньше
u >= q; // больше или равно
u <= q; // меньше или равно
u == q; // равно
u != q; // не равно
u === q; // строгое равно
u !== q; // строгое не равно

// Операторы сравнения возвращают значение логического типа (true, false)

alert(2 > 1); // true

// Результат сравнения можно присвоить переменной, как и любое значение

let result = 5 > 4;

//_ Сравнение строк (сравниваются посимвольно)

alert('Б' > 'А'); // true
alert('Скрипт' > 'Скрипка'); // true
alert('Слайдер' > 'Слайд'); // true
alert('сизый' > 'Сизый'); // true

//_ Сравнение чисел

// true: 5 > 1, 5 >= 1 и 5 != 1
// false: 5 < 1, 5 <= 1 и 5 == 1

//_ Сравнение true и false

// true: true > false, true >= false и true != false
// false: true < false, true <= false и true == false

//_ Сравнение разных типов данных

// при сравнении значений разных типов JavaScript приводит каждое из них к числу

alert('2' > 1); // true, строка '2' становится числом 2
alert('01' == 1); // true, строка '01' становится числом 1

alert(true == 1); // true
alert(false == 0); // true

// забавная ситуация:

let zeroNum = 0;
let zeroStr = '0';

alert(zeroNum == zeroStr); // true, при преобразовании в число

alert(Boolean(zeroNum)); // false, при преобразовании в булевый тип
alert(Boolean(zeroStr)); // true, при преобразовании в булевый тип

//_ Строгое сравнение
/*
Операторы строгого равенства ===, строгого не равентства !==
проверяет равенство без приведения типов.
*/
alert(0 === false); // false
alert('007' === 7); // false
alert('2' !== 2); // true

//_ Сравнение null и undefined

// При нестрогом сравнении (==) null и undefined равны друг другу
// и не равны никаким другим значениям (не путать с <=, >=):

alert(null == undefined); // true
alert(null === undefined); // false

// Сравнение null и 0

alert(null == 0); // false, null равен только undefined при нестрогом сравнении
alert(null > 0); // false, null преобразуется в 0
alert(null >= 0); // true, null преобразуется в 0

// Сравнение undefined и 0

alert(undefined == 0); // false, undefined равен только null при нестрогом сравнении
alert(undefined > 0); // false, undefined преобразуется в NaN
alert(undefined >= 0); // false, undefined преобразуется в NaN

// NaN – это специальное числовое значение, которое возвращает false при любых сравнениях

/*
Лучше не использовать сравнения >= > < <= с переменными,
которые могут принимать значения null / undefined.
Лучше используйте строгое сравнение, это поможет избежать проблем.
*/

// * Логические операторы

//` Оператор || (ИЛИ)

// result = value1 || value2 || value3;
/*
- вычисляет операнды слева направо, конвертируя операнды в логическое значение
- если результат конвертации true, останавливается и возвращает исходное значение этого операнда
- если все операнды являются ложными (false), возвращает значение последнего из них
*/

alert(1 || 0); // 1
alert(true || 'какая-то строка'); // true

alert(null || 1); // 1
alert(null || 0 || 1); // 1
alert(undefined || null || 0); // 0

/*
Может использоваться для получения первого истинного значения
из списка переменных или выражений.

То есть, оператор || возвращает первый операнд, значение которого
не являются 0, "", null, undefinded, NaN или false.

Если таковых нет, то возвращатеся последний операнд.
*/

let boolVal = false,
  strVal = '',
  numVal = 4,
  someVal;

alert(boolVal || strVal || numVal || someVal || 'не найдено'); // 4

// Сокращённое вычисление

true || alert('hello'); // ничего не получим в консоли
false || alert('hey there'); // 'hey there'

//` Оператор && (И)

// result = value1 && value2 && value3;
/*
Выполняет следующие действия:
- вычисляет операнды слева направо, конвертируя операнды в логическое значение
- если результат конвертации false, останавливается и возвращает исходное значение этого операнда
- если все операнды были истинными (true), возвращает значение последнего
*/

alert(1 && 0); // 0
alert(1 && 5); // 5

alert(null && 5); // null
alert(0 && 'string'); // 0

// Приоритет && больше, чем у ||

// alert(1 && 0 || 2 && 1); // 1

// Сокращённое вычисление (подобие условия if)

let users = 1;
users > 0 && alert(`Пользователей ${users}`);

if (users > 0) {
  alert(`Пользователей ${users}`);
}

//` Оператор ! (НЕ)

// result = !value;
/*
- приводит аргумент к логическому типу (true / false).
- возвращает противоположное значение.
*/

alert(!true); // false
alert(!0); // true
alert(!'hello'); // false

// Приоритет у НЕ ! выше, чем у && или ||

// alert(!true && 2 || 4 && 1); // 1

// Используется для преобразованя типа в boolean

alert(!!null); // false, используются 2 оператора логического отрицания
alert(Boolean(null)); // false

//` Оператор нулевого слияния (??)

// result = a ?? b
/* 
- возвращает первый аргумент, если он не null / undefined, иначе второй.
(анологичен с result = (a !== null && a !== undefined) ? a : b)
*/

let user;
alert(user ?? 'Без имени'); // 'Без имени'

user = 'John';
alert(user ?? 'Без имени'); // 'John'

// Сравнение с ||

/* 
Операторы || и ?? похожи, различие между ними состоит в том, что:
- || возвращает первое истинное значение (не 0, "", null, undefinded, NaN или false)
- ?? возвращает первое опеределенное значение (не null и не undefined)
*/

let height = 0;

alert(height || 100); // 100
alert(height ?? 100); // 0

/* 
Приоритет оператора ?? такой же, как и у ||, он ниже, чем у &&, !
и математических операторов (+, -, *, / и тд):
*/

let hg = null;
let wd = null;

let area = (hg ?? 100) * (wd ?? 50); // важно использовать круглые скобки
alert(area); // 5000

/* 
По соображениям безопасности запрещено использование оператора ?? вместе с && и ||
если приоритет явно не указан при помощи круглых скобок
*/

// let res = 1 && 2 ?? 3; // синтаксическая ошибка

let res = (1 && 2) ?? 3; // работает без ошибок
alert(res); // 2

// Дополнительно

/* 
Следующие операторы добавлены в язык недавно,
для их использования в старых браузерах может понадобится полифил.
*/

//` ||= (Логическое присваивание ИЛИ)

// a ||= b;
/* 
- вычисляет операнды слева направо, конвертируя a в логическое значение
- если a ложно, присваивает a значение b.

(аналогичен с a || (a = b))
*/

let person = ''; // оператор ||= преобразует пустую строку "" к логическому значению false

person ||= 'Неизвестная личность'; // то же самое, что false || (person = "...")
alert(person); // 'Неизвестная личность'

//` &&= (Логическое присваивание И)

// a &&= b;
/* 
- вычисляет операнды слева направо, конвертируя a в логическое значение
- если a истинно, присваивает a значение b.

(аналогичен с a && (a = b))
*/

let greeting = 'Привет'; // строка непустая, поэтому будет преобразована к логическому значению true оператором &&=

greeting &&= greeting + ', пользователь!'; // то же самое, что true && (greeting = greeting + "...")
alert(greeting); // "Привет, пользователь!"
