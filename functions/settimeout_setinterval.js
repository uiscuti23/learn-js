// * Планирование: setTimeout и setInterval

/*
Мы можем вызвать функцию не в данный момент, а позже, через заданный интервал времени.

Для этого существуют два метода:

- setTimeout позволяет вызвать функцию единожды через заданный интервал времени
- setInterval позволяет вызывать функцию регулярно, повторяя вызов через заданный интервал
*/

//_ setTimeout

/*
Синтаксис:
` let timerId = setTimeout(func | code, [delay], [arg1], [arg2], ...)

func|code - функция или строка кода для выполнения
delay - задержка перед запуском в миллисекундах. По умолчанию - 0
arg1, arg2 ... - аргументы, передаваемые в функцию
*/

function greeting() {
  alert('Привет');
}
setTimeout(greeting, 1000); // greeting вызывается спустя 1 секунду

// С аргументами:

function sayHi(phrase, who) {
  alert(phrase + ', ' + who);
}
setTimeout(sayHi, 1000, 'Привет', 'Джон'); // 'Привет, Джон'

// Если первый аргумент - строка, JS создаст из неё функцию:
setTimeout("alert('Привет')", 1000);

// Использование строк не рекомендуется, используйте функции:
setTimeout(() => alert('Привет'), 1000);

/* 
Передавайте функцию, но не запускайте её!
В setTimeout мы передаем саму функцию, не вызывая её: setTimeout(greeting, 1000)
*/

//' Отмена через clearTimeout

/* 
Вызов setTimeout возвращает «идентификатор таймера» timerId,
который можно использовать для отмены дальнейшего выполнения.

` let timerId = setTimeout(...);
` clearTimeout(timerId);
*/

let timerId = setTimeout(() => alert('ничего не происходит'), 1000);
alert(timerId); // идентификатор таймера

clearTimeout(timerId);
alert(timerId); // тот же идентификатор (не принимает значение null после отмены)

/* 
в браузере идентификатором таймера является число. В других средах это может быть что-то ещё.
Например, Node.js возвращает объект таймера с дополнительными методами.
*/

//_ setInterval

/* 
Синтаксис:
` let timerId = setInterval(func | code, [delay], [arg1], [arg2], ...)

Отличие этого метода от setTimeout в том, что функция запускается не один раз,
а периодически через указанный интервал времени.

Чтобы остановить дальнейшее выполнение функции, необходимо вызвать clearInterval(timerId).

Следующий пример выводит сообщение каждые 2 секунды. Через 5 секунд вывод прекращается:
*/

let timer = setInterval(() => alert('tick'), 2000); // повторить с интервалом 2 секунды

setTimeout(() => {
  clearInterval(timer); // остановить вывод через 5 секунд
  alert('stop');
}, 5000);

//_ Вложенный setTimeout

/* 
Есть два способа запускать что-то регулярно.
Один из них setInterval. Другим является вложенный setTimeout. Например:
*/

let timer_id = setTimeout(function tick() {
  alert('tick');
  timer_id = setTimeout(tick, 2000);
}, 2000);

/* вместо:
let timerId = setInterval(() => alert('tick'), 2000);
*/

/* 
Метод setTimeout выше планирует следующий вызов прямо после окончания текущего.

Вложенный setTimeout – более гибкий метод, чем setInterval. С его помощью последующий вызов 
может быть задан по-разному в зависимости от результатов предыдущего.

Вложенный setTimeout позволяет задать задержку между выполнениями более точно, чем setInterval.

Сравним два фрагмента кода:
*/

// Первый использует setInterval:

let i = 1;

setInterval(function () {
  func(i);
}, 100);

// Второй использует вложенный setTimeout:

let j = 1;
setTimeout(function run() {
  func(j);
  setTimeout(run, 100);
}, 100);

/* 
Выполнение некой функции func будет занимать некоторое время, (допустим 60 мс).

1. В случае с setInterval, время, затраченное на выполнение func, использует часть заданного интервала времени.

В данном случае движок ждёт окончания выполнения func и затем проверяет планировщик и, если время истекло,
немедленно запускает его снова.

В крайнем случае, если функция всегда выполняется дольше, чем задержка delay, (допустим 120 мс)
то вызовы будут выполняться без задержек вообще.


.		|								|								|								|
.		|---------|			|---------|			|---------|			|
----|func(1)	|-----|func(2)	|-----|func(3)	|-----|								(setInterval) func выполняется ~ 60ms
.		|---------|			|---------|			|---------|			|
.		|								|								|								|
.		|<------------->|<------------->|<------------->|
.		|			100ms			|			100ms			|			100ms			|


.		|								|								|								|
.		|------------------||------------------||------------------|			
----|func(1)	         ||func(2)	         ||func(3)	         |		(setInterval) func выполняется ~ 120ms
.		|------------------||------------------||------------------|
.		|								|								|								|
.		|<------------->|<------------->|<------------->|
.		|			100ms			|			100ms			|			100ms			|


2. Вложенный setTimeout гарантирует фиксированную задержку (здесь 100 мс).

Это потому, что новый вызов планируется в конце предыдущего. Тоесть установленная задержка в 100 мс
сработает только после выполнения функции func, неважно, сколько она будет выполняться.


.		|													|													|													|
.		|---------|								|---------|								|---------|								|
----|func(1)	|<------------->|func(2)	|<------------->|func(3)	|<------------->|				(вложенный setTimeout)
.		|---------|			100ms			|---------|			100ms			|---------|			100ms			|		
.		|													|													|													|				
*/

//_ setTimeout с нулевой задержкой

// Синтаксис: setTimeout(func, 0) или setTimeout(func)

/* 
Это планирует вызов func настолько быстро, насколько это возможно. Но планировщик будет
вызывать функцию только после завершения выполнения текущего кода.
*/

setTimeout(() => alert('Мир')); // или setTimeout(() => alert('Мир'), 0)

alert('Привет');

/*
В консоли сначала выведется "Привет", затем "Мир".
Но планировщик будет вызывать функцию сразу после завершения
выполнения текущего кода
*/

// Дополнительно

//_ Сборка мусора и колбэк setTimeout/setInterval

/* 
Когда функция передаётся в setInterval/setTimeout, на неё создаётся внутренняя ссылка
и сохраняется в планировщике. Это предотвращает попадание функции в сборщик мусора,
даже если на неё нет других ссылок.
*/

// функция остаётся в памяти до тех пор, пока планировщик обращается к ней
setTimeout(function () {}, 100);

/* 
Для setInterval функция остаётся в памяти до тех пор, пока не будет вызван clearInterval.

Есть и побочный эффект. Функция ссылается на внешнее лексическое окружение,
поэтому пока она существует, внешние переменные существуют тоже.
Они могут занимать больше памяти, чем сама функция.

Поэтому, если регулярный вызов функции больше не нужен, то лучше отменить его,
даже если функция очень маленькая.

Функция запоминается в том виде, какой она была в момент передачи в setInterval/setTimeout.
Это означает, что если позже мы изменим код этой функции, то все равно setInterval/setTimeout
будет вызывать её первоначальную версию (до изменения)
*/

//_ Минимальная задержка вложенных таймеров в браузере

/* 
После пяти вложенных таймеров интервал должен составлять не менее четырёх миллисекунд.

Аналогичное происходит при использовании setInterval вместо setTimeout:
setInterval(f) запускает f несколько раз с нулевой задержкой, а затем с задержкой 4+ мс.

Этого ограничения нет в серверном JavaScript. Там есть и другие способы планирования
асинхронных задач. Например, setImmediate для Node.js.

Так что это ограничение относится только к браузерам.
*/

// * итог

/* 
Методы setInterval(func, delay, ...args) и setTimeout(func, delay, ...args) позволяют
выполнять func регулярно или только один раз после задержки delay, заданной в мс.

Для отмены выполнения необходимо вызвать clearInterval/clearTimeout со значением,
которое возвращают методы setInterval/setTimeout.

Вложенный вызов setTimeout является более гибкой альтернативой setInterval.
Также он позволяет более точно задать интервал между выполнениями.

Планирование с нулевой задержкой setTimeout(func,0) или, что то же самое,
setTimeout(func) используется для вызовов, которые должны быть исполнены как можно скорее,
после завершения исполнения текущего кода.

Браузер ограничивает 4-мя мс минимальную задержку между пятью и более вложенными
вызовами setTimeout, а также для setInterval, начиная с 5-го вызова.

Обратим внимание, что все методы планирования не гарантируют точную задержку.

Например, таймер в браузере может замедляться по многим причинам:

- перегружен процессор.
- вкладка браузера в фоновом режиме.
- работа ноутбука от аккумулятора.

Всё это может увеличивать минимальный интервал срабатывания таймера
(и минимальную задержку) до 300 или даже 1000 мс в зависимости от браузера
и настроек производительности ОС.
*/
