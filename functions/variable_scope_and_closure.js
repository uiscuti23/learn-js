// * Область видимости переменных, замыкание

//_ Блоки кода

/* 
Если переменная объявлена внутри блока кода {...}, то она видна только внутри этого блока.
То же самое относится для if, for, while и т.д:
*/

// Пример

{
  let message = 'Hello';
  alert(message); // 'Hello'
}

alert(message); // ReferenceError: message is not defined

// Пример с if

if (true) {
  let phrase = 'Hello';
  alert(phrase); // 'Hello'
}

alert(phrase); // Ошибка, нет такой переменной!

// Пример с for

for (let i = 0; i < 3; i++) {
  alert(i); // 0, потом 1, потом 2
}

alert(i); // Ошибка!

/* 
Визуально let i = 0; находится вне блока кода {...}, однако здесь в случае с for
есть особенность: переменная, объявленная внутри (...), считается частью блока.
*/

//_ Вложенные функции

/* 
Функция называется «вложенной», когда она создаётся внутри другой функции.

Вложенная функция может быть возвращена: либо в качестве свойства нового объекта
(если внешняя функция создаёт объект с методами), либо сама по себе,
и затем использована в любом месте кода. 

При этом, она будет иметь доступ к внешним переменным внешней функции.
*/

function greeting(firstName, lastName) {
  function getFullName() {
    return firstName + ' ' + lastName;
  }

  alert('Hello, ' + getFullName());

  return getFullName;
}

let getName = greeting('John', 'Smith'); // 'Hello, John Smith'

let fullName = getName();
alert(fullName); // 'John Smith'

// пример с функцией-конструктором

function User(name) {
  this.sayHi = function () {
    alert(name);
  };
}
let user = new User('Alex');

user.sayHi(); // 'Alex'

/* 
Заметим, что в последнем примере user не имеет свойство name: 'Alex', а лишь один метод.
Этот метод ссылается на значение параметра name функции-конструктора.

Ниже, makeCounter создает функцию «счётчик», которая при каждом вызове возвращает следующее число:
*/

function makeCounter() {
  let count = 0;

  return function () {
    return count++;
  };
}

let counter = makeCounter();

alert(counter()); // 0
alert(counter()); // 1
alert(counter()); // 2

/* 
Как это работает? Если мы создадим несколько таких счётчиков, будут ли они независимыми друг от друга?
Что происходит с переменными? Давайте немного углубимся.
*/

//_ Лексическое окружение (LexicalEnvironment)

/*
У каждой выполняемой функции, блока кода и скрипта есть
связанный с ними внутренний скрытый объект - лексическое окружение.

Он состоит из двух частей:

1. Environment Record - объект, где хранятся все локальные
переменные, также иная информация (такая как значение this).

2. Ссылка на внешнее лексическое окружение [[Enviroment]]

Переменная является свойством объекта Environment Record.
Работа с переменными - это на самом деле работа со свойствами этого объекта.
Аргументы (параметры) функций тоже становятся локальными переменными!

У глобального лексического окружения нет внешнего окружения (ссылается на null)
*/

// Процесс объявления, присваивания, изменения переменной:

/*
начало выполнения --------- <uninitialized> 		--> null
let phrase; --------------- phrase: undefined
phrase = 'hello'; --------- phrase: 'hello'
phrase = 'bye'; ----------- phrase: 'bye'

В состоянии "uninitialized" движок знает о переменной, но на неё нельзя ссылаться (использовать её),
пока она не будет объявлена с помощью let.
*/

/* 
Function Declaration, в отличии от переменных, объявленных с помощью let и const,
инициализируется когда создаётся лексическое окружение (в момент вызова функции!),
а не тогда, когда выполнение доходит до них.

Инициализация — процесс присвоения начального значения.

Как говорилось ранее, у локального (внутреннего) лексического окружения
есть ссылка на внешнее окружение.

Когда код хочет получить доступ к переменной - сначала происходит поиск в локальном
лексическом окружении, затем во внешнем, затем в следующем и тд, до глобального.

Если переменная не была найдена, это будет ошибкой в строгом режиме (use strict).
Без строгого режима создаётся новая глобальная переменная с таким же именем.
*/

/* 
Замыкание - это способность функции в JS запоминать лексическое окружение,
в котором она была создана (с помощью скрытого свойства [[Enviroment]]),
вследствие чего она может получить доступ к внешним переменным.

Все функции являются замыканиями, кроме функций, созданных с использованием синтаксиса "new Function".
*/

function makeCounter() {
  let count = 0;

  return function () {
    return count++;
  };
}

let counter1 = makeCounter(); // совершается вызов функции makeCounter, создается ее лексическое окружение (в схеме ниже соответвует makeCounter #1)
// counter1 будет содержать в себе безымянную функцию, возвращаемой функцией makeCounter

let counter2 = makeCounter(); // ...то же самое

alert(counter1()); // 0
alert(counter1()); // 1
alert(counter1()); // 2

alert(counter2()); // 0
alert(counter2()); // 1

/* 
В примере совершаются 2 вызова функции makeCounter, создавая 2 независимых друг от друга лексических окружения.

Переменная обновляется в том лексическом окружении, в котором она существует.
Вызовы counter1 и counter2 меняют значение переменной counter из своего внешнего лексического окружения
независимо друг от друга.

Для простоты в схеме свойство [[Environment]] заменено на "ссылку", Environment Record - на "переменные",
лексическое окружение сокращено как л.о.

counter1:																	makeCounter #1:
{																					{
	ссылка: makeCounter #1,			-->						ссылка: глобальное л.о.,			---	
	переменные: {}														переменные: { count: 0 }					|						Глобальное л.о.:
}																					}																		|						{
.																																							|---->				ссылка: null,
counter2:																	makeCounter #2:											|							переменные: {}
{																					{																		|						}
	ссылка: makeCounter #2,			-->						ссылка: глобальное л.о.,			---
	переменные: {}														переменные: { count: 0 }
}																					}
*/

/* 
«Лексическое окружение» – это объект спецификации: он существует только «теоретически».
Мы не можем получить этот объект в нашем коде и манипулировать им напрямую.

JavaScript-движки также могут оптимизировать его, отбрасывать неиспользуемые переменные
для экономии памяти и выполнять другие внутренние действия
*/

// Дополнительно

// Разберем пример:

function createIncrement() {
  let count = 0;
  function increment() {
    count++;
  }

  let message = `Count is ${count}`;
  function log() {
    console.log(message);
  }

  return [increment, log];
}

const [increment, log] = createIncrement();

increment();
increment();
increment();
log(); // Что выведется в консоль?

/* 
Вызов функции createIcrement возвращает массив функций. При вызове функции log
в консоли получим: 'Count is 0'. Почему так?

Потому что при вызове функции createIcrement переменная message создается
динамически со значением count, равным нулю, единожды, и больше его значение
не меняется.

Для того, чтобы вызов log показывал актуальное значение count, нужно строку
с объявлением переменной message переместить внутрь функции log.
*/

//_ Сборка мусора

/* 
Обычно лексическое окружение удаляется из памяти вместе со всеми переменными
после завершения вызова функции. Это связано с тем, что на него нет ссылок.

Как и любой объект JavaScript, оно хранится в памяти только до тех пор,
пока к нему можно обратиться.

Однако если существует вложенная функция, которая все еще доступна после завершения функции,
то она имеет свойство [[Environment]], ссылающееся на лексическое окружение.

В этом случае лексическое окружение остается доступным даже после завершения работы функции.
*/

function f() {
  let value = 123;

  return function () {
    alert(value);
  };
}

let g = f(); // g.[[Environment]] хранит ссылку на лексическое окружение из соответствующего вызова f()

// g = null; // объект лексического окружения исчезает, когда становится недоступным (память очищается)

/* 
Если вложенная функция f() вызывается много раз и результирующие функции сохраняются,
то все соответствующие объекты лексического окружения также будут сохранены в памяти.

В приведенном ниже коде – все три:
*/

function f() {
  let value = Math.random();

  return function () {
    alert(value);
  };
}

// 3 функции в массиве, каждая из которых ссылается на лексическое окружение
// из соответствующего вызова f()
let arr = [f(), f(), f()];
