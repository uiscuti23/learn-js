// * Декораторы и переадресация вызова, call/apply

/*
В JS функции могут передаваться в другие функции, использоваться
как объекты. Также рассмотрим, как перенаправлять вызовы между функциями
и декорировать функции.
*/

//_ Прозрачное кеширование

/*
Функцию можно заключить в функцию-обёртку - "wrapper", допустим,
для того, чтобы кешировать(запоминать) значения, возвращаемые
этой функцией.

Функцию-обёртку называют декоратором. Она принимает другую функцию
и изменяет его поведение.
*/

function slow(x) {
  // здесь могут быть ресурсоёмкие вычисления
  alert(`Called with ${x}`);
  return x;
}

function cachingDecorator(func) {
  let cache = new Map();

  return function (x) {
    if (cache.has(x)) {
      // если кеш содержит такой x,
      return cache.get(x); // читаем из него результат
    }

    let result = func(x); // иначе, вызываем функцию

    cache.set(x, result); // и кешируем (запоминаем) результат
    return result;
  };
}

slow = cachingDecorator(slow);

alert(slow(1)); // slow(1) кешируем
alert('Again: ' + slow(1)); // возвращаем из кеша

alert(slow(2)); // slow(2) кешируем
alert('Again: ' + slow(2)); // возвращаем из кеша

/* 
cachingDecorator – декоратор. Мы можем вызвать его с любой функцией,
в результате чего мы получим кеширующую обёртку.

Это здорово, т.к. у нас может быть множество функций, использующих такую функциональность,
и всё, что нам нужно сделать – это применить к ним cachingDecorator.

Отделяя кеширующий код от основного кода, мы также сохраняем чистоту и простоту последнего.

Результат вызова cachingDecorator(func) является «обёрткой»,
т.е. function(x) «оборачивает» вызов func(x) в кеширующую логику.

С точки зрения внешнего кода, обёрнутая функция slow по-прежнему делает то же самое.
Обёртка всего лишь добавляет к её поведению аспект кеширования.

Подводя итог, можно выделить несколько преимуществ использования
отдельной cachingDecorator вместо изменения кода самой slow:

- функцию cachingDecorator можно использовать повторно. Мы можем применить её к другой функции.
- логика кеширования является отдельной, она не увеличивает сложность самой slow (если таковая была).
- при необходимости мы можем объединить несколько декораторов (речь об этом пойдёт позже).
*/

// Дополнительно: детальный разбор примера с декоратором

function slow(x) {
  alert(`Slow ${x}`);
  return x;
}

function cachingDecorator(func) {
  let cache = new Map();

  return function (x, clearMap = false) {
    alert(`clearMap: ${clearMap}`);
    alert(cache);

    if (cache.has(x)) {
      let res = cache.get(x);
      if (clearMap) {
        cache.clear();
        alert(cache);
      }
      return res;
    }

    let result = func(x);

    cache.set(x, result);

    return result;
  };
}

slow = cachingDecorator(slow); // вызывается cachingDecorator, принимающая как аргумент функцию slow,
// возвращается функция function (x, clearMap = false) {...}, которая присваивается как новое значение для переменной slow

// function (x, clearMap = false) {...} ссылается на лексическое окружение вызова cachingDecorator, где содержится cashe
// эта функция имеет второй параметр clearMap, предусмотренный для возможности очистки данных из cashe

alert(slow(1));
alert('Again:', slow(1));

alert(slow(2));
alert('Again:', slow(2, true)); // получаем данные из кеша и очищаем его

alert(slow(3));

//_ Применение "func.call" для передачи контекста

/*
Давайте теперь обернем кеширующим декоратором метод объекта (строка (***1)).

Теперь методу slow(x) объекта worker будет присвоена функция function (x) {...},
которую возвращает функция-декоратор cachingDecorator(func).

Причем лексическое окружение возвращаемой функции будет ссылаться на лексическое окружение
декоратора, которая хранит в себе ссылку на переменные:
- func, значением которой будет worker.slow(x) (значение до кеширования, оригинальная функция, «вырванная» из контекста объекта worker)
- cache, где хранится Map

Декоратор не сможет работать с методами объектов,
которые ссылаются (используют) на другие свойства объекта.

Причина в том, что декоратор вызывает оригинальную функцию slow(x)
как func(x) в строке (**1), и она в данном случае получает this = undefined (в строгом режиме)
или this = window (глобальный объект, в не строгом режиме).

В любом случае мы не сможем получить доступ к свойствам объекта worker при вызове (**1).
Следовательно получим ошибку.

(метод slow(x) заимствуется у объекта worker и в строке (*1) использует
метод .someMethod(), к которому более не имеет доступа)

Для того, чтобы код заработал, используем встроенный метод функции
func.call(context, ...args), который позволяет вызвать функцию, явно устанавливая this
*/

let worker = {
  someMethod() {
    return 1;
  },

  slow(x) {
    alert('Called with ' + x);
    return x * this.someMethod(); // (*1)
  },
};

function cachingDecorator(func) {
  let cache = new Map();

  return function (x) {
    if (cache.has(x)) {
      return cache.get(x);
    }

    let result = func.call(this, x); // (**1) вместо let result = func(x)

    cache.set(x, result);
    return result;
  };
}

worker.slow = cachingDecorator(worker.slow); // (***1) метод slow объекта worker сделаем кеширующей

alert(worker.slow(2)); // работает
alert(worker.slow(2)); // работает, не вызывая первоначальную функцию (кешируется)

//_ Метод .call:

/*
Синтаксис:

` func.call(context, arg1, arg2)

Запускает функцию func, используя первый аргумент как её контекст
this, а последующие - как аргументы func
*/

function sayName() {
  alert(this.name);
}

function say(phrase) {
  alert(this.name + ': ' + phrase);
}

let user = { name: 'John' };
let admin = { name: 'Admin' };

sayName.call(admin); // 'Admin'
say.call(user, 'Hello'); // 'John: Hello'

/*
Метод call позволяет запускать функцию или метод объекта с заданным
контекстом.
*/

//_ Метод .apply

/* 
Синтаксис:

` func.apply(context, args)

Он выполняет func, устанавливая this = context и принимая в качестве
списка аргументов псевдомассив args.

Единственная разница в синтаксисе между call и apply состоит в том,
что call ожидает список аргументов, а apply принимает псевдомассив.

Эти два вызова почти эквивалентны:
func.call(context, ...args);
func.apply(context, args);

Для перебираемых (итерируемых) объектов сработает call, а для псевдомассивов - apply.

Если у нас есть массив, то для работы с call используем оператор расширения (...),
а для работы с apply передаем сам массив.

Использование apply, вероятно, будет быстрее, потому что большинство движков JavaScript
внутренне оптимизируют его лучше.
*/

// Пример с итерируемым объектом

let object = {
  someMethod() {
    return 1;
  },
};

function slow(...args) {
  return args.reduce((acc, item) => (acc *= item)) * this.someMethod();
}

let range_obj = {
  from: 1,
  to: 5,

  [Symbol.iterator]() {
    this.current = this.from;
    return this;
  },

  next() {
    if (this.current <= this.to) {
      return { done: false, value: this.current++ };
    } else {
      return { done: true };
    }
  },
};

alert(...range_obj); // 1 2 3 4 5

alert(slow.call(object, ...range_obj)); // 120
alert(slow.apply(object, [...range_obj])); // 120, для с apply элементы поместим в массив
alert(slow.apply(object, Array.from(range_obj))); // 120, для с apply элементы поместим в массив

/* 
Вспомним пример с кешурующим декоратором (строка 148). cachingDecorator в этом примере
работал только с функциями с одним аргументом (имел параметр x).

Давайте сделаем cachingDecorator ещё более универсальным: чтобы он мог
кешировать функции с произовольным количеством аргументов (параметров).
*/

let worker = {
  slow(min, max) {
    console.log(`Called with ${min},${max}`);
    return min + max;
  },
};

function cachingDecorator(func, hash) {
  let cache = new Map();
  return function () {
    let key = hash(arguments); // (*2)
    if (cache.has(key)) {
      return cache.get(key);
    }

    let result = func.call(this, ...arguments); // (**2)
    // let result = func.apply(this, arguments) // можно использовать также apply

    cache.set(key, result);
    return result;
  };
}

function hash(args) {
  return [...args].join();
}

worker.slow = cachingDecorator(worker.slow, hash);

console.log(worker.slow(3, 5)); // работает
console.log('Again ' + worker.slow(3, 5)); // аналогично (результат возвращается из кеша)

/*
Mетод slow объекта worker принимает два аргумента min и max.

В строке (*2) вызываем hash для создания ключа для cashe из arguments.
Здесь мы используем простую функцию «объединения», которая превращает аргументы (3, 5) в ключ "3,5".

Затем в строке (**2) используем func.call(this, ...arguments) для передачи как контекста,
так и всех аргументов, полученных обёрткой (независимо от их количества), в исходную функцию.

arguments - псевдомассив, хранящий в себе список аргументов функции при вызове
*/

//_ Заимствование метода

/* 
В примере выше, функция hash возвращает строку, используя метод join для массива.
Позаимствуем метод join у массива и применим его уже к псевдомассиву arguments
*/

function hash(arguments) {
  return [].join.call(arguments); // (***2)
}

/* 
Результат будет таким же, будет возвращаться результат выполнения функции join,
псевдомассив arguments будет использоваться как её контекст this (this = arguments).

Сам псевдомассив не имеет методов массива.

Не стоит путать со случаем, когда псевдомассив arguments передается как второй параметр
к методу apply (следующая закоментированная строка в примере, после (**2)),
тут arguments используется как первый аргумент к методу call, в качестве контекста,
у которого не заданы последующие параметры (строка (***2))
*/

// * итог

/* 
Декоратор – это обёртка вокруг функции, которая изменяет поведение последней.
Основная работа по-прежнему выполняется функцией.

Обычно безопасно заменить функцию или метод декорированным, за исключением одной мелочи.
Если исходная функция предоставляет свойства, такие как func.calledCount или типа того,
то декорированная функция их не предоставит. Потому что это обёртка.
Так что нужно быть осторожным в их использовании. Некоторые декораторы предоставляют свои собственные свойства.

Декораторы можно рассматривать как «дополнительные возможности» или «аспекты»,
которые можно добавить в функцию. Мы можем добавить один или несколько декораторов.
И всё это без изменения кода оригинальной функции!

Для реализации cachingDecorator мы изучили методы:

- func.call(context, arg1, arg2…) – вызывает func с данным контекстом и аргументами.
- func.apply(context, args) – вызывает func, передавая context как this
и псевдомассив args как список аргументов.

В основном переадресация вызова выполняется с помощью apply:
*/

let wrapper = function (original, arguments) {
  return original.apply(this, arguments);
};

/* 
Мы также рассмотрели пример заимствования метода, когда мы вызываем метод у объекта
в контексте другого объекта. Весьма распространено заимствовать методы массива и применять их к arguments.

В качестве альтернативы можно использовать объект с остаточными параметрами ...args,
который является реальным массивом.

На практике декораторы используются для самых разных задач.

У стрелочных функций нет this. Если происходит обращение к this, его значение берётся снаружи.

Следует это иметь ввиду при вызове методов call, apply и bind
(метод bind рассматривается в теме binding) для стрелочных функций.

Из-за отсутсвия собственного контекста (this) у стрелочных функций эти методы не будут работать.
*/
