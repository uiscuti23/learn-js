// * Рекурсия

/* 
Рекурсия (recursion) — это поведение функции, при котором она вызывает сама себя.
*/

//_ Два способа мышления

/*
Напишем функцию pow(x, n), которая возводит x в натуральную степень n.
Иначе говоря, умножает x на само себя n раз.

pow(2, 2) = 4
pow(2, 3) = 8
pow(2, 4) = 16

Рассмотрим два способа её реализации.
*/

// 1. Итеративный способ: цикл for:

function pow(x, n) {
  let result = 1;

  // умножаем result на x n раз в цикле
  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}

alert(pow(2, 3)); // 8

// 2. Рекурсивный способ: упрощение задачи и вызов функцией самой себя:

function pow(x, n) {
  return n == 1 ? x : x * pow(x, n - 1);
}

alert(pow(2, 3)); // 8

/* 
Обратите внимание, что рекурсивный вариант отличается принципиально.

Когда функция pow(x, n) вызывается, исполнение делится на две ветви:

1. n == 1.

Эта ветвь называется базой рекурсии, потому что сразу же приводит
к очевидному результату: pow(x, 1) равно x.

2. x * pow(x, n - 1).

Эта ветвь – шаг рекурсии: мы сводим задачу к более простому действию
(умножение на x) и более простой аналогичной задаче (pow с меньшим n).

Последующие шаги упрощают задачу всё больше и больше, пока n не достигает 1.

Например, рекурсивный вариант вычисления pow(2, 4) состоит из шагов:

pow(2, 4) = 2 * pow(2, 3)
pow(2, 3) = 2 * pow(2, 2)
pow(2, 2) = 2 * pow(2, 1)
pow(2, 1) = 2

Итак, рекурсию используют, когда вычисление функции можно свести к её более простому вызову,
а его – к ещё более простому и так далее, пока значение не станет очевидно.
*/

/* 
Общее количество вложенных вызовов (включая первый) называют глубиной рекурсии.
В нашем случае она будет равна n.

Максимальная глубина рекурсии ограничена движком JavaScript (10465 вызовов).

Для решения большого числа задач рекурсивный способ решения даёт более простой код,
который легче поддерживать.
*/

//_ Контекст выполнения, стек

/* 
Информация о процессе выполнения запущенной функции хранится в её контексте выполнения
(execution context).

Контекст выполнения – специальная внутренняя структура данных, которая содержит информацию
о вызове функции. Она включает в себя конкретное место в коде, на котором находится интерпретатор,
локальные переменные функции, значение this (мы не используем его в данном примере)
и прочую служебную информацию.

Один вызов функции имеет ровно один контекст выполнения, связанный с ним.

Когда функция производит вложенный вызов, происходит следующее:

- выполнение текущей функции приостанавливается.

- контекст выполнения, связанный с ней, запоминается в специальной структуре данных –
стеке контекстов выполнения.

- выполняются вложенные вызовы, для каждого из которых создаётся свой контекст выполнения.

- после их завершения старый контекст достаётся из стека, и выполнение
внешней функции возобновляется с того места, где она была остановлена.

Контексты на примере вызова функции pow(2, 3):

pow(2, 1) - контекст: {x: 2, n: 1} возвращает x = 2					➡ ➡
pow(2, 2) - контекст: {x: 2, n: 2} возвращает x = 2 * 2		⬆			⬇
pow(2, 3) - контекст: {x: 2, n: 3} возвращает x = 4 * 2		⬆			⬇

Глубина рекурсии равна максимальному числу контекстов, одновременно хранимых в стеке.

Обратим внимание на требования к памяти. Рекурсия приводит к хранению всех данных
для неоконченных внешних вызовов в стеке, и в данном случае это приводит к тому,
что возведение в степень n хранит в памяти n различных контекстов.

Итеративный вариант функции pow использует один контекст, в котором будут последовательно
меняться значения i и result. При этом объём затрачиваемой памяти небольшой, фиксированный
и не зависит от n.

Любая рекурсия может быть переделана в цикл. Как правило, вариант с циклом будет эффективнее.

Но переделка рекурсии в цикл может быть нетривиальной, особенно когда в функции в зависимости
от условий используются различные рекурсивные подвызовы, результаты которых объединяются,
или когда ветвление более сложное. Оптимизация может быть ненужной и совершенно нестоящей усилий.

Часто код с использованием рекурсии более короткий, лёгкий для понимания и поддержки.
Оптимизация требуется не везде, как правило, нам важен хороший код, поэтому она (рекурсия) и используется.
*/

//_ Рекурсивные обходы

/* 
Представьте, у нас есть компания. Структура персонала может быть представлена как объект.
Нужно реализовать функцию получения суммы зарплат работников.
*/

let company = {
  sales: [
    { name: 'John', salary: 1000 },
    { name: 'Alice', salary: 600 },
  ],
  development: {
    sites: [
      { name: 'Peter', salary: 2000 },
      { name: 'Alex', salary: 1800 },
    ],
    internals: [{ name: 'Jack', salary: 1300 }],
  },
};

function sumSalaries(department) {
  if (Array.isArray(department)) {
    return department.reduce((prev, current) => prev + current.salary, 0); // сумма элементов массива
  } else {
    let sum = 0;
    for (let subdep of Object.values(department)) {
      sum += sumSalaries(subdep); // рекурсивно вызывается для подотделов, суммируя результаты
    }
    return sum;
  }
}

alert(sumSalaries(company));

//_ Рекурсивные структуры

/* 
Рекурсивная структура данных - структура, которая повторяет саму себя
в своих частях
*/

//_ Связанный список

/* 
Элемент связанного списка определяется рекурсивно как объект с:

- value,
- next – свойство, ссылающееся на следующий элемент связанного списка или null,
если это последний элемент.
*/

let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null,
      },
    },
  },
};

// Альтернативный код создания:
let list2 = { value: 1 };
list2.next = { value: 2 };
list2.next.next = { value: 3 };
list2.next.next.next = { value: 4 };

// Разделение списка:
let secondList = list.next.next;
list.next.next = null;

// Объединение:
list.next.next = secondList;

// Добавление нового элемента в начало списка:
list = { value: 'new item', next: list };

// Удаление произвольного элемента(например c value 2)
list.next = list.next.next;

/* 
Недостаток связанного списка - мы не сможем легко получить доступ к элементу по его индексу
*/

// * итог

/* 
Рекурсия – это термин в программировании, означающий вызов функцией самой себя.
Рекурсивные функции могут быть использованы для элегантного решения определённых задач.

Когда функция вызывает саму себя, это называется шагом рекурсии. База рекурсии –
это такие аргументы функции, которые делают задачу настолько простой,
что решение не требует дальнейших вложенных вызовов.

Рекурсивно определяемая структура данных – это структура данных, которая может быть определена
с использованием самой себя.

Например, связанный список может быть определён как структура данных, состоящая из объекта,
содержащего ссылку на список (или null).

Любая рекурсивная функция может быть переписана в итеративную. И это иногда требуется
для оптимизации работы. Но для многих задач рекурсивное решение достаточно быстрое
и простое в написании и поддержке.
*/
