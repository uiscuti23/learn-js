// * Повторяем стрелочные функции

/* 
Стрелочные функции – это не просто «сокращение», чтобы меньше писать.
У них есть ряд других полезных особенностей.

При написании JavaScript-кода часто возникают ситуации, когда нам нужно написать небольшую функцию,
которая будет выполнена где-то ещё.

Например:

- arr.forEach(func) – func выполняется forEach для каждого элемента массива.
- setTimeout(func) – func выполняется встроенным планировщиком.				…и так далее.

Это очень в духе JavaScript – создать функцию и передать её куда-нибудь.

И в таких функциях мы обычно не хотим выходить из текущего контекста.
Здесь как раз и полезны стрелочные функции.
*/

//_ У стрелочных функций нет «this»

/* 
У стрелочных функций нет this. Если происходит обращение к this, его значение берётся снаружи.

Например, мы можем использовать это для итерации внутри метода объекта:
*/

let group = {
  title: 'Our Group',
  students: ['John', 'Pete', 'Alice'],

  showList() {
    this.students.forEach(student => alert(this.title + ': ' + student));
  },
};

group.showList();

/* 
Здесь внутри forEach использована стрелочная функция, таким образом this.title
в ней будет иметь точно такое же значение, как в методе showList: group.title.

Если бы мы использовали «обычную» функцию, была бы ошибка:
*/

let group1 = {
  title: 'Our Group',
  students: ['John', 'Pete', 'Alice'],

  showList() {
    this.students.forEach(function (student) {
      alert(this.title + ': ' + student); // Error: Cannot read property 'title' of undefined (при 'use strict')
    });
  },
};

group1.showList();

/* 
Ошибка возникает потому, что forEach по умолчанию выполняет функции с this, равным undefined,
и в итоге мы пытаемся обратиться к undefined.title.

Это не влияет на стрелочные функции, потому что у них просто нет this.
*/

//_ Стрелочные функции нельзя использовать с new

/* 
Отсутствие this естественным образом ведёт к другому ограничению:
стрелочные функции не могут быть использованы как конструкторы. Они не могут быть вызваны с new.
*/

//_ Стрелочные функции не работают с методами call, apply, bind

// Эти методы фиксируют контекст this для функции, но стрелочные функции не имеют своего контекста

//_ Стрелочные функции не имеют «arguments»

/* 
У стрелочных функций также нет переменной arguments.

Это отлично подходит для декораторов, когда нам нужно пробросить вызов с текущими this и arguments.

Например, defer(f, ms) принимает функцию и возвращает обёртку над ней,
которая откладывает вызов на ms миллисекунд:
*/

function defer(f, ms) {
  return function () {
    setTimeout(() => f.apply(null, arguments), ms);
  };
}

function sayHi(who) {
  alert('Hello, ' + who);
}

let sayHiDeferred = defer(sayHi, 2000);
sayHiDeferred('John'); // выводит "Hello, John" через 2 секунды

// То же самое без стрелочной функции выглядело бы так:

function defer(f, ms) {
  return function (...args) {
    setTimeout(function () {
      return f.apply(null, args);
    }, ms);
  };
}

/* 
Здесь мы были вынуждены создать дополнительные переменную args,
чтобы функция внутри setTimeout могла получить её.
*/

// * итог

/* 
Стрелочные функции:

Не имеют this.
Не имеют arguments.
Не могут быть вызваны с new.
У них также нет super (тема: class_inheritance 'Наследование классов').

Всё это потому, что они предназначены для небольшого кода,
который не имеет своего «контекста», выполняясь в текущем.

И они отлично справляются с этой задачей!
*/
