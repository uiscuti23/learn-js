// * Функции

/*
Функции придуманы для избавления дублирования кода.

Существуют 2 способа объявить функцию:
- Function Declaration (объявление функции)
- Function Expression (функциональное выражение), где функция становится значением переменной
*/

//* Function Declaration

//_ Объявление функции

function имя(параметры) {
  // тело (код) функции
}

/* 
Вначале идёт ключевое слово function, после него имя функции, затем список параметров
в круглых скобках через запятую (их может и не быть) и, наконец,
код функции, также называемый «телом функции», внутри фигурных скобок.
*/

// Пример:

function showMessage() {
  alert('Сообщение');
}

showMessage(); // Запуск функции

/*
Запускать функцию можно как после, так и перед объявлением.
Функция выполнится столько раз, сколько раз он будет вызван.
*/

//_ Локальные переменные

// Переменные, объявленные внутри функции, видны только внутри этой функции:

function showMessage() {
  let message = 'Привет, я JavaScript!'; // локальная переменная
  alert(message);
}
showMessage(); // 'Привет, я JavaScript!'

alert(message); // <-- будет ошибка, т.к. переменная видна только внутри функции

//_ Внешние переменные

// У функции есть доступ к внешним переменным, например:

let userName = 'Вася';

function showMessage() {
  let message = 'Привет, ' + userName;
  alert(message);
}
showMessage(); // 'Привет, Вася'

// Функция обладает полным доступом к внешним переменным и может изменять их значение:

let user_name = 'Вася';

function showMessage() {
  user_name = 'Петя'; // изменяем значение внешней переменной
  let message = 'Привет, ' + user_name;
  alert(message);
}

alert(user_name); // 'Вася' перед вызовом функции

showMessage();
alert(user_name); // 'Петя', значение внешней переменной было изменено функцией

/* 
Внешняя переменная используется, если внутри нет локальной с таким же именем.

Если одноимённая переменная объявляется внутри функции,
тогда она перекрывает внешнюю (внешняя переменная будет проигнорирована)
*/

let user = 'Вася';

function showMessage() {
  let user = 'Петя'; // объявляем локальную переменную

  let message = 'Привет, ' + user;
  alert(message);
}

showMessage(); // 'Привет, Петя'

alert(user); // 'Вася', функция не трогала внешнюю переменную

//_ Глобальные переменные

/*
Переменные, объявленные снаружи всех функций, называются глобальными.

Глобальные переменные видимы для любой функции (если только их
не перекрывают одноименные локальные).

Желательно сводить использование глобальных переменных к минимуму.
*/

//_ Параметры

/*
Можно передать внутрь функции любую информацию, используя
параметры (аргументы).

Мы объявляем функции со списком параметров внутри круглых
скобок, затем вызываем их, передавая аргументы.
*/

function showMessage(from, text) {
  // параметры: from, text
  alert(from + ': ' + text);
}

showMessage('Аня', 'Привет!'); // 'Аня: Привет!'
showMessage('Аня', 'Как дела?'); // 'Аня: Как дела?'

/*
Функция всегда получает только копию значения в качестве
параметра и не может изменить оригинал:
*/

function showMessage(from, text) {
  from = '^' + from + '^'; // немного украсим "from"
  alert(from + ': ' + text);
}

let from = 'Аня';
showMessage(from, 'Привет'); // '^Аня^: Привет'

alert(from); // 'Аня'

/*
Если при вызове функции аргумент не был указан,
то его значением становится undefined.

Отсутвие аргумента не приведёт к ошибке
*/

/*
Если мы хотим задать параметру значение по умолчанию, нужно
указать его после =
*/

function showMessage(from, text = 'текст не добавлен') {
  alert(from + ': ' + text);
}
showMessage('Аня'); // 'Аня: текст не добавлен'

/*
Параметром по умолчанию можно установить более сложное выражение,
которое вычислялось и присваивалось при отсутсвии аргумента:
*/

function showMessage(from, text = anotherFunction()) {
  // anotherFunction() выполнится только если не передан text
  // результатом будет значение text
}

//_ Возврат значения

/*
Функция может вернуть результат, который передастся в вызвавший её код,
используя директиву return:
*/

function sum(a, b) {
  return a + b;
}

let result = sum(1, 2);

alert(result); // 3

/* 
return может находиться в любом месте тела функции.
Как только выполнение доходит до него, функция останавливается,
и значение возвращается в вызвавший её код (присваивается переменной result выше)
*/

// Вызовов return может быть несколько:

function checkAge(number) {
  if (number % 2) {
    return 'нечетное число';
  } else {
    return 'четное число';
  }
}

/* 
Возможно использовать return и без значения.
Это приведёт к немедленному выходу из функции:
*/

function showNothing() {
  return;
  alert(1 + 1); // эта инструкция не выполнится
}

// Результат функции с пустым return или без него – undefined:

alert(showNothing() === undefined); // true

function showMessage() {
  alert('hello');
}

alert(showMessage() === undefined); // true

/*
Никогда не добавляйте перевод строки между return и его значением:

return
	(some + long + expression + or + whatever * f(a) + f(b))

Код не выполнится, потому что интерпретатор JavaScript подставит точку с запятой после return,
поэтому return станет пустым.

Если мы хотим, чтобы возвращаемое выражение занимало несколько строк,
нужно поставить там открывающую скобку:

return (
	some + long + expression
	+ or +
	whatever * f(a) + f(b)
	)

*/

//_ Выбор имени функции

/* 
Функция – это действие. Поэтому имя функции обычно является глаголом.
Оно должно быть кратким, точным и описывать действие функции
*/

/*
Как правило, в имени функции используются глагольные префиксы,
после которых следует уточнение.

Функции, начинающиеся с...
"show..." обычно что-то показывают,
"get..." - возвращают значение,
"calc..." - что-то вычисляют,
"create..." - что-то создают,
"check..." - что-то проверяют и возвращают логическое значение, и т.д.
*/

/*
Нужно стремиться к тому, чтобы функции были короткими и делали только что-то одно.
В последствии мы можем объединить эти функции при необходимости
*/

// * Функциональное выражение (Function Expression)

/* 
Function Expression является значением переменной.
В примере переменная sayHi будет хранить в себе функцию:
*/

let sayHi = function () {
  alert('Привет');
};

/* 
После ключевого слова function нет имени.
Для Function Expression допускается его отсутсвие.

Мы создаем некую функцию и помещаем ее в переменную sayHi
*/

/*
Независимо от того, как создаётся функция – она является значением переменной.

Мы можем его скопировать или вывести его с помощью alert.
*/

function sayHi() {
  alert('Привет');
}

alert(sayHi); // выведет код функции

let sayHiCopy = sayHi; // копируем

sayHi(); // 'Привет'
sayHiCopy(); // 'Привет'

// Функция – это значение, представляющее «действие»

//_ Функции-колбэки

/* 
Колбэк-функция (или обратный вызов) - это функция,
переданная в другую функцию в качестве аргумента,
которая затем вызывается по завершению какого-либо действия.

В примере функции showOk, showCancel передаются в качестве аргументов ask
*/

function ask(question, yes, no) {
  if (confirm(question)) yes();
  else no();
}

function showOk() {
  alert('Вы согласились.');
}

function showCancel() {
  alert('Вы отменили выполнение.');
}

ask('Вы согласны?', showOk, showCancel);

/*
Идея таких функций в том, что они сработают позже, если будет необходимо.
Функция showOk становится колбэком для параметра "yes", а showCancel для "no"
*/

// Мы можем переписать этот пример значительно короче, используя Function Expression:

function ask(question, yes, no) {
  if (confirm(question)) yes();
  else no();
}

ask(
  'Вы согласны?',
  function () {
    alert('Вы согласились.');
  },
  function () {
    alert('Вы отменили выполнение.');
  }
);

/* 
Здесь функции объявляются прямо внутри вызова ask(...).
У них нет имён, поэтому они называются анонимными.

Такие функции недоступны снаружи ask (потому что они не присвоены переменным)
*/

//_ Function Expression в сравнении с Function Declaration

/*
Function Expression - это функция, созданная внутри другого выражения
или синтаксической конструкции.

Function Declaration - функция объявляется отдельной конструкцией «function…»
в основном потоке кода

Function Expression создаётся, когда выполнение доходит до него,
и затем уже может использоваться.

Function Declaration может быть вызвана раньше, чем она объявлена.

Когда движок JavaScript готовится выполнить скрипт или блок кода,
прежде всего ищет в нем Function Declaration и создаёт такие функции (инициализирует их).

И после того, как все объявления Function Declaration будут обработаны, продолжится выполнение.
Поэтому такие функции могут быть вызваны раньше своих определений.

В строгом режиме Function Declaration, находящийся внутри блока {...}
будет доступен везде внутри этого блока, но не снаружи.
Тоесть его нельзя вызвать за пределами блока.

Для решения этой проблемы можно использовать Function Expression:
*/

let yourAge = prompt('Сколько Вам лет?', 18);

let sayWelcome;

if (age < 18) {
  sayWelcome = function () {
    alert('Привет!');
  };
}

sayWelcome();

// * Стрелочные функции (arrow functions)

// Синтаксис

let func = (arg1, arg2, ...argN) => expression;

// Является сокращенной версией Function Expression:

let funс = function (arg1, arg2, ...argN) {
  return expression;
};

// Пример сравнения стрелочной функции и Function Expression:

let sum = (a, b) => a + b;

let sum = function (a, b) {
  return a + b;
};

/*
Если у нас один аргумент, то круглые скобки вокруг параметров
можно опустить:
*/

let double = n => n * 2;
// примерно тоже что и: let double = function(n) { return n * 2 };

alert(double(3)); // 6

/*
Если аргументов нет, то круглые скобки будут пустыми, но они
должны присутствовать:
*/
let sayHi = () => alert('Hello!');

// Стрелочные функции можно использовать также, как и Function Expression

let your_age = prompt('Сколько Вам лет?', 18);

let welcome = your_age < 18 ? () => alert('Привет! Привет! Привет!') : () => alert('Здравствуйте!');

welcome();

//_ Многострочные стрелочные функции

/*
Если стрелочная функция с несколькими выражениями и инструкциями,
заключаем их в фигурные скобки {}.

В этом случае, если мы хотим возвратить значение, нужно явно указывать return:
*/

let sum = (a, b) => {
  let result = a + b;
  return result; // для возврата значения указываем "return"
};

alert(sum(1, 2)); // 3

//* Итого

/*
Передаваемые значения (аргументы) копируются в параметры функции
и становятся локальными переменными

Функции имеют доступ к внешним переменным.
Код вне функции не имеет доступа к её локальным переменным.

Функция может возвращать значение. Если этого
не происходит, возвращается undefined.

Функции - это значения. Они могут быть присвоены,
скопированы или объявлены в любом месте кода.


Если функция объявлена как отдельная инструкция в основном потоке кода,
то это “Function Declaration”.
Она обрабатываются перед выполнением блока кода.

Если функция была создана как часть выражения, то это “Function Expression”.
Она создаются только когда поток выполнения достигает ее.


Стрелочные функции удобны для простых действий, особенно для однострочных.

Если в теле стрелочной функции более находится более одной инструкции,
ее нужно обернуть в фигурные скобки.

В этом случае нужно явно вызвать return, если нужно вернуть значение
*/
