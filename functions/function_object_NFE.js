// * Объект функции

// Функции - это объекты

//_ Свойство "name"

/*
Большинство функций и методы объекта имеют свойство "name"
*/

function sayHi() {
  alert('Hi');
}
alert(sayHi.name); // 'sayHi'

// name находится корректно, даже когда функция создаётся без имени и тут же присваивается

let sayHi = function () {
  alert('Hi');
};

alert(sayHi.name); // 'sayHi'

// это работает даже в случае присваивания значения по умолчанию:

function f(sayHi = function () {}) {
  alert(sayHi.name); // 'sayHi'
}
f();

// имена имеют и методы объекта:

let user = {
  sayHi() {
    // ...
  },
  sayBye: function () {
    // ...
  },
};
alert(user.sayHi.name); // 'sayHi'
alert(user.sayBye.name); // 'sayBye'

/* 
В спецификации это называется «контекстное имя»: если функция не имеет name,
то JavaScript пытается определить его из контекста.
*/

//_ Свойство "length"

/*
Содержит количество параметров функции в её объявлении
*/
function f1(a) {}
function f2(a, b) {}
function many(a, b, ...more) {}

alert(f1.length); // 1
alert(f2.length); // 2
alert(many.length); // 2

/* 
Как мы видим, троеточие, обозначающее «остаточные параметры», здесь как бы «не считается»
*/

//_ Пользовательские свойства

// Мы также можем добавить свои собственные свойства:

function greeting() {
  alert('Hi');
  greeting.counter++;
}

greeting.counter = 0; // свойство функции

greeting(); // 'Hi'
greeting(); // 'Hi'

alert(`Вызвана ${greeting.counter} раза`); // 'Вызвана 2 раза'

/*
Свойство не есть переменная.

Свойство функции, назначенное как sayHi.counter = 0, не объявляет
локальную переменную counter внутри неё.

Другими словами, свойство counter и переменная let counter - разные вещи.

Можно использовать функцию как объект, хранить в ней свойства,
но они никак не влияют на её выполнение. Переменные – это не свойства функции и наоборот
*/

/*
Иногда свойства функции могут использоваться вместо замыканий. 
Присваивание свойства к функции облегчает его получение и изменение извне
*/

function makeCounter() {
  function counter() {
    return ++counter.count;
  }

  counter.count = 0;

  return counter;
}

let counter1 = makeCounter();
let counter2 = makeCounter();

counter1();
counter1();

alert(counter1.count); // 2

counter2.count = 10;
alert(counter2.count); // 10

//_ Named Function Expression

// NFE - это Function Expression, у которого есть имя:

let sayHi = function func(who) {
  alert(`Hello, ${who}`);
};

/*
Заметим, что функция всё ещё задана как Function Expression.
Добавление "func" после function не превращает объявление в Function Declaration.

Добавление такого имени ничего не ломает.

Особенности NFE:
1. Оно позволяет функции ссылаться на себя же.
2. Оно не доступно за пределами функции
*/

let sayHi = function func(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    func('Guest'); // использует func, чтобы снова вызвать себя же
  }
};
sayHi(); // 'Hello, Guest'

// А вот так - не cработает:
func(); // Ошибка, func не определена (недоступна вне функции)

/*
NFE нужен в случаях, где имеется какая-то функция, которая ссылается на себя.
При присвоении этой функции новой переменной и обнуления старой,
запуск новой функции выдаст ошибку, потому что она внутри ссылается на старое название.
*/

let sayHi1 = function (who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    sayHi1('Guest'); // Ошибка: sayHi не является функцией
  }
};

let welcome1 = sayHi1;
sayHi1 = null;

welcome1(); // Ошибка, вложенный вызов sayHi1 больше не работает!

// Используем NFE и всё работает:

let sayHi2 = function func(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    func('Guest'); // Теперь всё в порядке
  }
};

let welcome2 = sayHi2;
sayHi2 = null;

welcome2(); // 'Hello, Guest' (вложенный вызов работает)

/*
Этот трюк не работает с Function Declaration.
Если нам нужно надёжное "внутреннее" имя, стоит перезаписать его на Named Function Expression
*/

// * итого

/* 
Функции – это объекты.

Их свойства:

name – имя функции. Обычно берётся из объявления функции, но если там нет –
JavaScript пытается понять его из контекста.

length – количество аргументов в объявлении функции.
Троеточие («остаточные параметры») не считается.

Если функция объявлена как Function Expression (вне основного потока кода) и имеет имя,
тогда это называется Named Function Expression (Именованным Функциональным Выражением).

Это имя может быть использовано для ссылки на себя же, для рекурсивных вызовов и т.п.

Также функции могут содержать дополнительные свойства. Функция может не только делать что-то сама по себе,
но также и предоставлять полезную функциональность через свои свойства.
*/
