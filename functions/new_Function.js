// * Синтаксис "new Function"

/* 
Синтаксис:

` let func = new Function([arg1, arg2, ...argN], functionBody)

arg1...argN - аргументы (опционально),
functionBody - тело функции
*/

// пример такой функции с аргументами

let sum = new Function('a', 'b', 'return a + b');
alert(sum(1, 2)); // 3

// пример функции без аргументов, только с телом

let sayHi = new Function('alert("Hello")');
sayHi(); // 'Hello'

/*
new Function позволяет превратить любую строку в функцию.
Например, можно получить новую функцию с сервера и выполнить её:
*/

let str = /* ... код, полученный с сервера динамически ... */

let fn = new Function(str);
fn();


//_ Замыкание в "new Function"

/*
Когда функция создаётся с использованием new Function, в её [[Environment]] записывается
ссылка не на внешнее лексическое окружение, в котором она была создана, а на глобальное.

Поэтому такая функция имеет доступ только к глобальным переменным:
*/

function getFunc() {
	let value = "test";

	let func = new Function('alert(value)'); // эта функция не сможет получить доступ к value

	// let func = function() { console.log(value) } - этот вариант будет работать, т.к. он имеет доступ к value

	return func;
}
getFunc()(); // ошибка: value не определено

// Дополнительно

/* 
Особенность функций, созданных как new Function, не иметь доступ к внешним локальным переменным,
а только глобальным бывает очень полезна.

Дело в том, что перед отправкой JavaScript-кода на реальные работающие проекты код сжимается
с помощью минификатора – специальной программы, которая уменьшает размер кода, удаляя комментарии,
лишние пробелы, и, что самое главное, локальным переменным даются укороченные имена.

Например, если в функции объявляется переменная let userName, то минификатор изменяет её на let a
(или другую букву, если она не занята) и изменяет её везде.

Обычно так делать безопасно, потому что переменная является локальной, и никто снаружи не имеет к ней доступ.
И внутри функции минификатор заменяет каждое её упоминание.

Так что если бы даже new Function и имела доступ к внешним переменным,
она не смогла бы найти переименованную userName.

Если бы new Function имела доступ к внешним переменным, при этом были бы проблемы с минификаторами.

Кроме того, такой код был бы архитектурно хуже и более подвержен ошибкам.
Чтобы передать что-то в функцию, созданную как new Function, можно использовать её аргументы
*/

// * итог

/* 
Синтаксис:
` let func = new Function ([arg1, arg2, ...argN], functionBody)

По историческим причинам аргументы также могут быть объявлены через запятую в одной строке.
*/

// Эти 3 объявления ниже эквивалентны:

new Function('a', 'b', 'return a + b');	 // стандартный синтаксис
new Function('a,b', 'return a + b');		 // через запятую в одной строке
new Function('a , b', 'return a + b');	 // через запятую с пробелами в одной строке

/* 
Функции, объявленные через new Function, имеют [[Environment]], ссылающийся
на глобальное лексическое окружение, а не на родительское.

Поэтому они не могут использовать внешние локальные переменные.

Но это очень хорошо, потому что страхует нас от ошибок. Переданные явно параметры –
гораздо лучшее архитектурное решение, которое не вызывает проблем у минификаторов.
*/