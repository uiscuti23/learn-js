// * Привязка контекста к функции

//_ Потеря «this»

/* 
При передаче методов объекта в качестве колбэков, например для setTimeout,
возникает известная проблема – потеря this.

Как только метод передаётся отдельно от объекта – this теряется.
*/

let john = {
  firstName: 'John',
  greeting() {
    alert(`Hello! ${this.firstName}`);
  },
};

setTimeout(john.greeting, 1000); // 'Hello! undefined'

/* 
Это произошло потому, что setTimeout получил функцию greeting отдельно от объекта john
(именно здесь функция и потеряла контекст).

То есть последняя строка может быть переписана как:
*/

let f = john.greeting;
setTimeout(f, 1000); // контекст john потеряли

{
  // Детальная информация о контексте внутри функций

  /*

Внутри функций, не являющиеся стрелочными функциями или методами объекта,
при наличии 'use strict' this=undefined, а при отсутствии - this=window.

Таким образом, такие функции не имеют контекста.
В нестрогом режиме контекстом будет являться глобальный объект.

Стрелочные функции не имеют своего this, значение взаимствуется снаружи (из внешнего лексического окружения).

На глобальном уровне this=window.
*/

  function fn() {
    alert(this); // undefined или Window

    function func() {
      alert(this); // undefined или Window
    }
    func();
  }

  fn();

  alert(this); // Window

  let arrowFunc = () => alert(this); // Window
  arrowFunc();

  let alex = {
    name: 'Alex',

    method() {
      alert(this); // {name: 'Alex', ...}

      let arrow_in_method = () => alert(this); // {name: 'Alex', ...}
      arrow_in_method();
    },
    arrowMethod: () => alert(this), // Window
  };

  alex.method();
  alex.arrowMethod();
}

/* 
Метод setTimeout устанавливает this=window для вызова функции (вне зависимости от наличия 'use strict')
(в Node.js this становится объектом таймера, но здесь это не имеет значения).

Таким образом, для this.firstName он пытается получить window.firstName, которого не существует.
Следовательно, мы получаем как результат undefined.

Как сделать так, чтобы метод вызывался в правильном контексте?

Имеется 2 решения:
*/

//_ Решение 1: сделать функцию-обёртку

/* 
Оборачиваем вызов в анонимную функцию, создав замыкание:
*/

let user = {
  firstName: 'John',
  greeting() {
    alert(`Hello! ${this.firstName}`);
  },
};

setTimeout(() => user.greeting(), 1000); // 'Hello! John'

/* 
Выглядит хорошо, но теперь в нашем коде появилась небольшая уязвимость.

Если до момента срабатывания setTimeout (задержка составляет 1 сек)
перезаписать переменную user или метод user.greeting, то вызов
вернет иной результат, например:
*/

setTimeout(() => user.greeting(), 1000); // 'Changed method'

user.greeting = () => alert('Changed method');

//_ Решение 2: привязать контекст с помощью bind

/* 
У функций есть встроенный метод bind, который позволяет зафиксировать this.
*/

setTimeout(() => user.greeting.bind(user), 1000); // 'Hello! John'

// или

let greeting = user.greeting.bind(user); // (*)
setTimeout(() => greeting, 1000); // 'Hello! John'

/* 
Здесь greeting.bind(user) – это «связанный вариант» greeting, с фиксированным this=user.

В строке (*) мы берём метод user.greeting и привязываем его к user.
Теперь greeting – это «связанная» функция, которая может быть вызвана отдельно
или передана в setTimeout (контекст всегда будет правильным).
*/

// Рассмотрим пример, где у метода есть параметры:

let person = {
  firstName: 'Alex',
  say(phrase) {
    alert(`${phrase}, ${this.firstName}!`);
  },
};

let say = user.say.bind(person);

say('Hello'); // 'Hello, Alex' (аргумент "Hello" передан в функцию "say")
say('Bye'); // 'Bye, Alex' (аргумент "Bye" передан в функцию "say")

/* 
Если у объекта много методов и мы планируем их активно передавать,
то можно привязать контекст для них всех в цикле:
*/

for (let key in user) {
  if (typeof user[key] == 'function') {
    user[key] = user[key].bind(user);
  }
}

//_ Фиксирование параметров с помощью bind

/* 
Мы можем привязать не только this, но и аргументы. Это делается редко, но иногда может быть полезно.

Полный синтаксис bind:
` let bound = func.bind(context, [arg1], [arg2], ...)

Это позволяет привязать контекст this и начальные аргументы функции.

Например, у нас есть функция умножения mul.
Создадим функции double и triple на его основе:
*/

function mul(a, b) {
  return a * b;
}

let double = mul.bind(null, 2);

alert(double(3)); // = mul(2, 3) = 6
alert(double(4)); // = mul(2, 4) = 8
alert(double(5)); // = mul(2, 5) = 10

let triple = mul.bind(null, 3);

alert(triple(5)); // = mul(3, 5) = 15

/* 
Вызов mul.bind(null, 2) создаёт новую функцию double, которая передаёт вызов mul,
фиксируя null как контекст, и 2 – как первый аргумент. Следующие аргументы передаются как есть.

В данном случае мы на самом деле не используем this. Но для bind это обязательный параметр, 
так что мы должны передать туда что-нибудь вроде null.

2 - фиксированный аргумент, он считается первым аргументом, который мы не передаем
при вызове double. При вызове double передается второй аргумент (в примере это числа 3, 4, 5)
*/

/* 
Для чего мы обычно создаём частично применённую функцию?

Польза от этого в том, что возможно создать независимую функцию
с понятным названием (double, triple).

Мы можем использовать её и не передавать каждый раз первый аргумент,
т.к. он зафиксирован с помощью bind.

В других случаях частичное применение полезно, когда у нас есть очень общая функция
и для удобства мы хотим создать её более специализированный вариант.

Например, у нас есть функция send(from, to, text). Потом внутри объекта user
мы можем захотеть использовать её частный вариант: sendTo(to, text),
который отправляет текст от имени текущего пользователя.
*/

//_ Применение bind без контекста

/* 
Что если мы хотим зафиксировать некоторые аргументы, но не контекст this?
Например, для метода объекта.

Встроенный bind не позволяет этого. Мы не можем просто опустить контекст и перейти к аргументам.

К счастью, легко создать вспомогательную функцию partial, которая привязывает только аргументы
*/

function partial(func, ...argsBound) {
  return function (...args) {
    return func.call(this, ...argsBound, ...args);
  };
}

let user_1 = {
  firstName: 'John',
  say(time, phrase) {
    alert(`[${time}] ${this.firstName}: ${phrase}!`);
  },
};

user_1.sayNow = partial(user_1.say, new Date().getHours() + ':' + new Date().getMinutes());

user_1.sayNow('Hello'); // '[10:00] John: Hello!'

/* 
Результатом вызова partial(func[, arg1, arg2...]) будет обёртка function (...args) {...},
которая вызывает func с:

- тем же this, который она получает (для вызова user.sayNow – это будет user_1)
- затем передаёт ей ...argsBound – аргументы из вызова partial ("10:00")
- затем передаёт ей ...args – аргументы, полученные обёрткой ("Hello")

В этом примере для user_1 создаётся новый метод sayNow, которая возвращает
результат вызова метода say с this=user_1: return say.call(this, 'часы:минуты', 'Hello').

Так как say принимает 2 аргумента, то partial для этого примера можно переписать так:
*/

function partial(func, argBound) {
  return function (arg) {
    return func.call(this, argBound, arg);
  };
}

// * итог

/* 
Метод bind возвращает «привязанный вариант» функции func,
фиксируя контекст this и первые аргументы arg1, arg2…, если они заданы.

Обычно bind применяется для фиксации this в методе объекта,
чтобы передать его в качестве колбэка. Например, для setTimeout.

Когда мы привязываем аргументы, такая функция называется «частично применённой» или «частичной».

Частичное применение удобно, когда мы не хотим повторять один и тот же аргумент много раз.

Например, если у нас есть функция send(from, to) и from всё время будет одинаков для нашей задачи,
то мы можем создать частично применённую функцию и дальше работать с ней.
*/
