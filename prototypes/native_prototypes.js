// * Встроенные прототипы

// Давайте выведем пустой объект:

let object = {};
alert(object); // "[object Object]" (здесь действительно подразумевается alert, а не console.log)

/* 
Как функция alert генерирует строку "[object Object]"?
Его генерирует встроенный метод toString, но где он? object ведь пуст!

Краткая нотация obj = {} – это то же самое, что и obj = new Object(),
где Object – встроенная функция-конструктор для объектов, где его свойство prototype
ссылается на огромный объект с методом toString и другими.

Таким образом, когда вызывается obj.toString(), метод берётся из Object.prototype:
*/

console.log(object.toString()); // "[object Object]"

alert(object.__proto__ === Object.prototype); // true

// obj.toString === obj.__proto__.toString === Object.prototype.toString

/* 
Обратите внимание, что по цепочке прототипов выше Object.prototype больше нет свойства [[Prototype]]: */

alert(Object.prototype.__proto__); // null

//_ Другие встроеннные прототипы

/* 
Другие встроенные объекты, такие как Array, Date, Function и другие, также хранят
свои методы в прототипах.

Например, при создании массива [1, 2, 3] внутренне используется конструктор массива Array.
Поэтому прототипом массива становится Array.prototype, предоставляя ему свои методы.
*/

let arr = [1, 2, 3];

// наследует ли от Array.prototype?
alert(arr.__proto__ === Array.prototype); // true

// затем наследует ли от Object.prototype?
alert(arr.__proto__.__proto__ === Object.prototype); // true

// и null на вершине иерархии
alert(arr.__proto__.__proto__.__proto__); // null

/* 
Некоторые методы в прототипах могут пересекаться, например, у Array.prototype есть
свой метод toString, который выводит элементы массива через запятую.

Как мы видели ранее, у Object.prototype есть свой метод toString, но так как Array.prototype
ближе в цепочке прототипов, то берётся именно вариант для массивов:
*/

let array = [1, 2, 3];
alert(array); // 1,2,3 <-- результат Array.prototype.toString (подразумевается alert, а не console.log)

/* 
Другие встроенные объекты устроены аналогично. Даже функции – они объекты встроенного
конструктора Function, и все их методы (call/apply и другие) берутся из Function.prototype.
Также у функций есть свой метод toString
*/

//_ Примитивы

/* 
Как мы помним, примитивы не объекты. Но если мы попытаемся получить доступ к их свойствам,
то тогда будет создан временный объект-обёртка с использованием встроенных конструкторов
String, Number и Boolean, который предоставит методы и после этого исчезнет.

Методы этих объектов также находятся в прототипах, доступных как String.prototype,
Number.prototype и Boolean.prototype.

Значения null и undefined не имеют объектов-обёрток, так что методы и свойства им недоступны.
Также у них нет соответствующих прототипов.
*/

//_ Изменение встроенных прототипов

/* 
Встроенные прототипы можно изменять. Например, если добавить метод к String.prototype,
метод становится доступен для всех строк:
*/

String.prototype.show = function () {
  alert(this);
};

'BOOM!'.show(); // BOOM!

/* 
В течение процесса разработки у нас могут возникнуть идеи о новых встроенных методах,
которые нам хотелось бы иметь, и искушение добавить их во встроенные прототипы. Это плохая идея.

Прототипы глобальны, поэтому очень легко могут возникнуть конфликты.
Если две библиотеки добавляют метод String.prototype.show, то одна из них перепишет метод другой.
*/

/* 
В современном программировании есть только один случай, в котором одобряется изменение
встроенных прототипов. Это создание полифилов.

Полифил – это термин, который означает эмуляцию метода, который существует в спецификации
JavaScript, но ещё не поддерживается текущим движком JavaScript.

Тогда мы можем реализовать его сами и добавить во встроенный прототип:
*/

if (!String.prototype.repeat) {
  // Если такого метода нет
  // добавляем его в прототип

  String.prototype.repeat = function (n) {
    // повторить строку n раз

    return new Array(n + 1).join(this);
    // значенем this будет строка, к которой применится метод join и
    // она будет разделителем glue между элементами со значением undefined

    // [undefined, undefined, ...].join('La')
  };
}

alert('La'.repeat(3)); // 'LaLaLa'

//_ Заимствование методов

/* 
Можно одалживать методы встроенных прототипов. Например, если мы создаём объект,
похожий на массив (псевдомассив), мы можем скопировать некоторые методы из Array в этот объект.
*/

let obj = {
  0: 'Hello',
  1: 'world!',
  length: 2,
};

obj.join = Array.prototype.join;

alert(obj.join(',')); // 'Hello,world!'

/* 
Альтернативная возможность – мы можем унаследовать от массива, установив obj.__proto__
как Array.prototype, таким образом все методы Array станут автоматически доступны в obj.
*/

const obj1 = {
  0: 'Hello',
  1: 'World',
  length: 2,
  __proto__: Array.prototype,
};

alert(obj1.at(-1)); // 'World'

// * итого

/*
Все встроенные объекты следуют одному шаблону:
- методы хранятся в прототипах (Array.prototype, Object.prototype, Date.prototype и т.д.).
- сами объекты хранят только данные (элементы массивов, свойства объектов, даты).

Примитивы также хранят свои методы в прототипах объектов-обёрток: Number.prototype,
String.prototype, Boolean.prototype. Только у значений undefined и null нет объектов-обёрток.

Встроенные прототипы могут быть изменены или дополнены новыми методами. Но не рекомендуется менять их.
Единственная допустимая причина - создание полифилов
*/
