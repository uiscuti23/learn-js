// * Наследование классов

/*
Это способ расширения одного класса другим.
К новому классу можно добавить новый функционал
*/

//_ Ключевое слово "extends"

class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  run(speed) {
    this.speed = speed;
    alert(`${this.name} бежит со скоростью ${this.speed}`);
  }
  stop() {
    this.speed = 0;
    alert(`${this.name} стоит неподвижно`);
  }
}

let animal = new Animal('Мой питомец');

animal.run(5); // 'Мой питомец бежит со скоростью 5'
animal.stop(); // 'Мой питомец стоит неподвижно'

alert(animal); // { speed: 0, name: 'Мой питомец' }

/* 
Еще мы бы хотели создать класс для кроликов.

Поскольку кролики – это животные, класс Rabbit должен быть основан на Animal,
и иметь доступ к методам животных, так чтобы кролики могли делать то,
что могут делать «общие» животные.

Синтаксис для расширения другого класса следующий: class Child extends Parent
*/

class Rabbit extends Animal {
  hide() {
    alert(`${this.name} прячется!`);
  }
}

let rabbit = new Rabbit('Белый кролик');

rabbit.run(5); // 'Белый кролик бежит со скоростью 5'
rabbit.hide(); // 'Белый кролик прячется!'

/* 
Объект класса Rabbit имеет доступ как к методам Rabbit, таким как rabbit.hide(),
так и к методам Animal, таким как rabbit.run().

Прототипом rabbit будет Rabbit.prototype (с constructor и hide), а прототипом Rabbit -
Animal.prototype (с constructor, run и stop).

Напомню, что при создании экземпляра класса или функции-конструктора оператор new
устанавливает в качестве [[Prototype]] значение свойства "prototype" (объект со свойством
constructor и другими методами, если они есть)

Animal																Object.prototype
|-----------------|										|---------------------------|
| constructor  		|		prototype				| constructor: Animal    		|
| 								| ---------------> 	| run: function							|
| 								|										| stop: function						|
|-----------------|										|---------------------------|		

.																										⬆
.																							[[Prototype]] 	<---- extends
.																										⬆
Rabbit																Rabbit.prototype									 
|-----------------|										|---------------------------|
| constructor			|		prototype				| constructor: Rabbit	   		|
| 								| ---------------> 	| hide: function		 				|
|-----------------|										|---------------------------|		

.																										⬆
.																							[[Prototype]]
.																										⬆
.																				new Rabbit()											
.																				|-----------------------|
.																				|	name: "Белый кролик"	|	
.																				|-----------------------|
*/

// После extends можно указать не только класс, но и функцию:

function f(phrase) {
  return class {
    sayHi() {
      alert(phrase);
    }
  };
}

class User extends f('Привет') {}
new User().sayHi(); // 'Привет'

/* 
Это может быть полезно для продвинутых приёмов проектирования, где мы можем использовать
функции для генерации классов в зависимости от многих условий и затем наследовать их.
*/

//_ Переопределение методов

/*
По умолчанию все методы, не указанные в классе Rabbit, берутся непосредственно «как есть»
из класса Animal.

Но если мы укажем в Rabbit собственный метод, например stop(),
то он будет использован вместо него.

Если нужно создать анологичный метод в дочернем классе, изменив или расширив
его функциональность, можно использовать ключевое слово "super".

- super.method(...) вызывает родительский метод.
- super(...) для вызова родительского конструктора (работает только внутри нашего конструктора)
*/

class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }

  run(speed) {
    this.speed = speed;
    console.log(`${this.name} бежит со скоростью ${this.speed}.`);
  }

  stop() {
    this.speed = 0;
    console.log(`${this.name} стоит.`);
  }
}

class Rabbit extends Animal {
  hide() {
    console.log(`${this.name} прячется!`);
  }

  stop() {
    super.stop(); // вызываем родительский метод stop
    this.hide(); // и затем hide
  }
}

let longEar = new Rabbit('Белый кролик');

longEar.run(5); // 'Белый кролик бежит со скоростью 5.'
longEar.stop(); // 'Белый кролик стоит.' 'Белый кролик прячется!'

/* 
Теперь у класса Rabbit есть метод stop, который вызывает родительский super.stop()
в процессе выполнения.
*/

//' У стрелочных функций нет super

// При обращении к super стрелочной функции он берётся из внешней функции:

class Rabbit extends Animal {
  stop() {
    // вызывает родительский stop после 1 секунды
    setTimeout(() => super.stop(), 1000);
  }
}

/* 
В примере super в стрелочной функции тот же самый, что и в stop(), поэтому метод
отрабатывает как и ожидается. Если бы мы указали здесь «обычную» функцию, была бы ошибка:
*/

setTimeout(function () {
  super.stop();
}, 1000); // Unexpected super

//_ Переопределение конструктора

/*
Если у дочернего класса нет конструктора, то он создаётся автоматически
(будет вызывать конструктор родительского класса со всеми параметрами):
*/

class Rabbit extends Animal {
  constructor(...args) {
    super(...args);
  }
}

/*
Если в дочерних классах мы устанавливаем конструкторы, то они должны вызывать super(...)
со всеми нужными параметрами (!) перед использованием this. ... (то есть вызываем super
сразу же первой инструкцией внутри constuctor):
*/

class Animal {
  constructor(name) {
    this.name = name;
    this.isPet = true;
    this.speed = 0;
  }
  // ...
}

class Rabbit extends Animal {
  constructor(name, earLength) {
    super(name); // вот тут
    this.earLength = earLength;
  }
  // ...
}

/*
Но почему так? Есть разница между запусками constructor у базового класса Animal и
наследующего класса Rabbit:
- при выполнении constructor у Animal, создаётся пустой объект, к которому присваивается this
- при выполнении constructor у Rabbit, не создается пустой объект. Вместо этого ожидается,
что это сделает конструктор родительского класса.

Поэтому, если мы создаём собственный конструктор, мы должны вызвать super, в противном случае
объект для this не будет создан, и мы получим ошибку.
*/

//_ Переопределение полей класса

/*
При запуске родительский конструктор всегда использует своё собственное значение поля,
а не переопределённое.
*/

class Animal {
  name = 'animal';

  constructor() {
    alert(this.name);
  }
}

class Rabbit extends Animal {
  name = 'rabbit';
}

new Animal(); // 'animal'
new Rabbit(); // 'animal'

/*
new Rabbit() вызывает super(), выполняя конструктор родительского класса, и только
после этого инициализируются поля его класса. (конструктор у Rabbit создан автоматически).

На момент выполнения еще нет полей класса Rabbit, поэтому используются поля Animal.

В этом кроется различие между полями и методами наследующих классов. В случае с методами
в приоритете выполнится переопределенный метод у Rabbit:
*/

class Animal {
  showName() {
    alert('animal'); // вместо this.name = 'animal'
  }

  constructor() {
    this.showName(); // вместо alert(this.name);
  }
}

class Rabbit extends Animal {
  showName() {
    alert('rabbit');
  }
}

new Animal(); // 'animal'
new Rabbit(); // 'rabbit'

// Дополнительно

//_ [[HomeObject]]

/*
Методы запоминают свой объект во внутреннем свойстве [[HomeObject]].
Благодаря этому работает super, он в прототипе этого объекта ищет родительские методы.

Другими словами, когда функция объявлена как метод внутри класса или объекта, её свойство [[HomeObject]]
становится равно этому объекту. Затем super использует его, чтобы получить прототип родителя и его методы.
*/

let animal_obj = {
  name: 'Животное',

  // animal_obj.eat.[[HomeObject]] === animal_obj
  eat() {
    console.log(`${this.name} ест.`);
  },
};

let rabbit_obj = {
  name: 'Кролик',

  // rabbit_obj.eat.[[HomeObject]] === rabbit_obj
  eat() {
    super.eat();
  },
  __proto__: animal,
};

let longEar_obj = {
  name: 'Длинноух',

  // longEar_obj.eat.[[HomeObject]] === longEar_obj
  eat() {
    super.eat();
  },
  __proto__: rabbit,
};

// работает верно
longEar.eat(); // 'Длинноух ест.'

//' Методы не «свободны»

/* 
До этого мы неоднократно видели, что функции в JavaScript «свободны», не привязаны к объектам.
Их можно копировать между объектами и вызывать с любым this.

Но само существование [[HomeObject]] нарушает этот принцип, так как методы запоминают свои объекты.
[[HomeObject]] нельзя изменить, эта связь – навсегда.

Единственное место в языке, где используется [[HomeObject]] – это super. Поэтому если метод
не использует super, то мы все ещё можем считать его свободным и копировать между объектами.

А вот если super в коде есть, то возможны побочные эффекты.
*/

let animalObj = {
  greeting() {
    alert('I am Animal');
  },
};

let rabbitObj = {
  greeting() {
    super.greeting();
  },
  __proto__: animalObj,
};

let plantObj = {
  greeting() {
    alert(`I am Plant`);
  },
};

let treeObj = {
  greeting: rabbitObj.greeting, // (*)
  __proto__: plantObj,
};

treeObj.greeting(); // 'I am Animal' (?!?)

/* 
В строке (*), метод treeObj.greeting скопирован из rabbit. Возможно, мы хотели избежать дублирования кода?
Его [[HomeObject]] – это rabbitObj, ведь он был создан в rabbit. Свойство [[HomeObject]] никогда не меняется.
В коде treeObj.greeting() есть вызов super.greeting(). Он идёт вверх от rabbit и берёт метод из animal.
*/

//' [[HomeObject]] не работает для свойств-функций, а только для методов

/* 
Свойство [[HomeObject]] определено для методов как классов, так и обычных объектов. Но для объектов
методы должны быть объявлены именно как method(), а не "method: function()".

В приведённом ниже примере используется синтаксис не метода, свойства-функции. Поэтому у него нет
[[HomeObject]], и наследование не работает:
*/

let beast = {
  eat: function () {
    // намеренно пишем так, а не eat() { ...
    // ...
  },
};

let bunny = {
  __proto__: beast,
  eat: function () {
    super.eat();
  },
};

bunny.eat(); // Ошибка вызова super (потому что нет [[HomeObject]])

// * итого

/* 
1. Чтобы унаследовать от класса: class Child extends Parent:
- при этом Child.prototype.__proto__ будет равен Parent.prototype, так что методы будут унаследованы.

2. При переопределении конструктора:
- обязателен вызов конструктора родителя super() в конструкторе Child до обращения к this.

3. При переопределении другого метода:
- мы можем вызвать super.method() в методе Child для обращения к методу родителя Parent.

4. Внутренние детали:
- методы запоминают свой объект во внутреннем свойстве [[HomeObject]]. Благодаря этому работает super,
он в его прототипе ищет родительские методы.
- поэтому копировать метод, использующий super, между разными объектами небезопасно.

Также:
- у стрелочных функций нет своего this и super, поэтому они «прозрачно» встраиваются во внешний контекст.
*/
