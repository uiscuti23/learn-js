// * Приватные и защищённые методы и свойства

/* 
Один из важнейших принципов объектно-ориентированного программирования –
разделение внутреннего и внешнего интерфейсов.
*/

//_ Пример из реальной жизни

/* 
Например, кофеварка. Простая снаружи: кнопка, экран, несколько отверстий…
И, конечно, результат – прекрасный кофе! :)

Но внутри… Множество деталей. Но мы можем пользоваться ею, ничего об этом не зная.
Секрет надёжности и простоты кофеварки – все детали хорошо отлажены и спрятаны внутри.

Если мы снимем защитный кожух с кофеварки, то пользоваться ею будет гораздо сложнее
(куда нажимать?) и опаснее (может привести к поражению электрическим током).

Как мы увидим, в программировании объекты похожи на кофеварки.

Но, чтобы скрыть внутренние детали, мы будем использовать не защитный кожух,
а специальный синтаксис языка и соглашения.
*/

/*
В объектно-ориентированном программировании свойства и методы разделены на 2 группы:

Внутренний интерфейс – методы и свойства, доступные из других методов класса, но не снаружи класса.
Внешний интерфейс – методы и свойства, доступные снаружи класса.

Всё, что нам нужно для использования объекта, это знать его внешний интерфейс.
Мы можем совершенно не знать, как это работает внутри, и это здорово.

В JavaScript есть два типа полей (свойств и методов) объекта:

- публичные: доступны отовсюду. Они составляют внешний интерфейс.
- приватные: доступны только внутри класса. Они для внутреннего интерфейса.

Во многих других языках также существуют «защищённые» поля, доступные только внутри класса или
для дочерних классов. Защищённые поля не реализованы в JavaScript на уровне языка,
но на практике они очень удобны, поэтому их эмулируют.
*/

//_ Защищенные свойства

/* 
Защищённые свойства обычно начинаются с префикса _.

В следующем примере реализуем защищенные свойства _waterAmount и _power, причем _power
будет доступен только для чтения (сеттер для него будет отсутствовать):
*/

class CoffeeMachine {
  _waterAmount = 0;

  constructor(power) {
    this._power = power;
  }

  get power() {
    return this._power;
  }

  set waterAmount(value) {
    if (value < 0) throw new Error('Отрицательное количество воды');
    this._waterAmount = value;
  }

  get waterAmount() {
    return this._waterAmount;
  }
}

// создаём новую кофеварку
let coffeeMachine = new CoffeeMachine(100);

alert(`Мощность: ${coffeeMachine.power}W`); // 'Мощность: 100W'

coffeeMachine.power = 25; // Ничего не произойдет, нет сеттера
alert(coffeeMachine.power); // 100

// устанавливаем количество воды
coffeeMachine.waterAmount = -10; // Error: Отрицательное количество воды

/* 
В данном примере мы использовали синтаксис геттеров/сеттеров для свойства _waterAmount.
Но в большинстве случаев использование функций get.../set... предпочтительнее:
*/

class CoffeeMachine {
  _waterAmount = 0;

  setWaterAmount(value) {
    if (value < 0) throw new Error('Отрицательное количество воды');
    this._waterAmount = value;
  }

  getWaterAmount() {
    return this._waterAmount;
  }
}

new CoffeeMachine().setWaterAmount(100);

/* 
Это выглядит немного длиннее, но функции более гибкие. Они могут принимать несколько аргументов
(даже если они нам сейчас не нужны).

С другой стороны, синтаксис get/set короче, решать вам.
*/

/* 
Если мы унаследуем class MegaMachine extends CoffeeMachine, ничто не помешает нам обращаться
к this._waterAmount или this._power из методов нового класса.

Таким образом, защищённые поля, конечно же, наследуются. В отличие от приватных полей,
в чём мы убедимся ниже.
*/

//_ Приватные свойства

/* 
Приватные свойства и методы должны начинаться с #. Они доступны только внутри класса.
Мы не можем получить к нему доступ извне или из наследуемых классов.
*/

class CoffeeMachine {
  #waterLimit = 200;

  #checkWater(value) {
    if (value < 0) throw new Error('Отрицательный уровень воды');
    if (value > this.#waterLimit) throw new Error('Слишком много воды');
  }
}

let coffeeMachine = new CoffeeMachine();

// снаружи  нет доступа к приватным свойствам и методам класса
coffeeMachine.#checkWater(); // Error
coffeeMachine.#waterLimit = 1000; // Error

/* 
Приватные поля не конфликтуют с публичными. У нас может быть два поля одновременно –
приватное #waterAmount и публичное waterAmount:
*/

class CoffeeMachine {
  #waterAmount = 0;

  get waterAmount() {
    return this.#waterAmount;
  }

  set waterAmount(value) {
    if (value < 0) throw new Error('Отрицательный уровень воды');
    this.#waterAmount = value;
  }
}

let machine = new CoffeeMachine();

machine.waterAmount = 100;

alert(machine.waterAmount); // 100
// alert(machine.#waterAmount); // Error

/* 
Если мы унаследуем от CoffeeMachine, то мы не получим прямого доступа к #waterAmount.
Мы будем вынуждены полагаться на геттер/сеттер waterAmount.
*/

// Приватные поля особенные. Мы не можем получить доступ к ним с помощью this[name]:

class CoffeeMachine {
  #waterAmount = 100;
  brand = 'Philips';

  show(key) {
    console.log(this[key]);
  }
}

let machine = new CoffeeMachine();

machine.show('brand'); // 'Philips'
machine.show('#waterAmount'); // undefined

// * итог

/* 
В терминах ООП отделение внутреннего интерфейса от внешнего называется инкапсуляция.

Это даёт следующие выгоды:

1. Защита для пользователей, чтобы они не выстрелили себе в ногу

Если пользователь класса изменит вещи, не предназначенные для изменения извне –
последствия непредсказуемы.

2. Поддерживаемость

Если мы чётко отделим внутренний интерфейс, то разработчик класса сможет свободно менять
его внутренние свойства и методы, не информируя пользователей.

3. Сокрытие сложности

Всегда удобно, когда детали реализации скрыты, и доступен простой, хорошо документированный
внешний интерфейс.

Для сокрытия внутреннего интерфейса мы используем защищённые или приватные свойства:

- защищённые поля имеют префикс _.

Это хорошо известное соглашение, не поддерживаемое на уровне языка. Программисты должны
обращаться к полю, начинающемуся с _, только из его класса и классов, унаследованных от него.

- приватные поля имеют префикс #.

JavaScript гарантирует, что мы можем получить доступ к таким полям только внутри класса.
*/
