//* Обработка ошибок, "try..catch"

/* 
Неважно, насколько мы хороши в программировании, иногда наши скрипты содержат ошибки.

Они могут возникать из-за наших промахов, неожиданного ввода пользователя,
неправильного ответа сервера и по тысяче других причин.

Обычно скрипт в случае ошибки «падает» (сразу же останавливается),
с выводом ошибки в консоль.

Но есть синтаксическая конструкция try..catch, которая позволяет «ловить» ошибки
и вместо падения делать что-то более осмысленное.
*/

//_ Синтаксис «try…catch»

// Конструкция try..catch состоит из двух основных блоков: try, и затем catch:

try {
  // код...
} catch (err) {
  // обработка ошибки
}

/* 
Работает она так:

1. Сначала выполняется код внутри блока try {...}.

2. Если в нём нет ошибок, то блок catch(err) игнорируется:
выполнение доходит до конца try и потом далее, полностью пропуская catch.

3. Если же в нём возникает ошибка, то выполнение try прерывается,
и поток управления переходит в начало catch(err).

Переменная err (можно использовать любое имя) содержит объект ошибки
с подробной информацией о произошедшем.

Таким образом, при ошибке в блоке try {…} скрипт не «падает»,
и мы получаем возможность обработать ошибку внутри catch.
*/

// Пример без ошибок: выведет alert (1) и (2):

try {
  alert('Начало блока try'); // (1) <-- начало

  // ...код без ошибок

  alert('Конец блока try'); // (2) <-- конец
} catch (err) {
  alert('Catch игнорируется, так как нет ошибок'); // (3)
}

// Пример с ошибками: выведет (1) и (2):

try {
  alert('Начало блока try'); // (1) <-- начало

  lalala; // ошибка, переменная не определена! <-- выполнение прерывается (при ошибке)

  alert('Конец блока try (никогда не выполнится)'); // (2)
} catch (err) {
  alert(`Возникла ошибка!`); // (3) <-- конец (выполняется блок catch при ошибке в try)
}

//' try..catch работает только для ошибок, возникающих во время выполнения кода!

/* 
Чтобы try..catch работал, код должен быть корректным.

Он не сработает, если код синтаксически неверен, например,
содержит несовпадающее количество фигурных скобок:

try {
  {{{{{{{{{{{{
} catch(e) {
  alert("Catch игнорируется, некорректный код, в консоли получим ошибку");
}

JavaScript-движок сначала читает код, а затем исполняет его.

Ошибки, которые возникают во время фазы чтения, называются ошибками парсинга.
Их нельзя обработать (изнутри этого кода), потому что движок не понимает код.
*/

//' try..catch работает с синхронным кодом, но не с асинхронным!

/* 
try..catch не будет ждать выполнения асинхронного кода, тоесть не будет
отлавливать ошибки, если они есть.
*/

try {
  setTimeout(function () {
    noSuchVariable; // скрипт упадёт тут, переменная с таким именем не была объявлена ранее
  }, 1000);
} catch (e) {
  alert('не сработает');
}

/* 
Это происходит потому, что функция выполняется позже,
когда движок уже покинул конструкцию try..catch.

Чтобы поймать исключение внутри запланированной функции,
try..catch должен находиться внутри самой этой функции:
*/

setTimeout(function () {
  try {
    noSuchVariable; // try..catch обрабатывает ошибку!
  } catch {
    alert('ошибка поймана!');
  }
}, 1000);

//_ Объект ошибки

/* 
Когда возникает ошибка, JavaScript генерирует объект, содержащий её детали.
Затем этот объект передаётся как аргумент в блок catch:
*/

try {
  // ...
} catch (err) {
  // err <-- объект ошибки, можно использовать другое название вместо err
  // ...
}

/* 
Для всех встроенных ошибок этот объект имеет два основных свойства:

name - имя ошибки. Например, для неопределённой переменной это "ReferenceError".
message - текстовое сообщение о деталях ошибки.

В большинстве окружений доступны и другие, нестандартные свойства.
Одно из самых широко используемых и поддерживаемых – это:

stack - текущий стек вызова: строка, содержащая информацию о последовательности
вложенных вызовов, которые привели к ошибке. Используется в целях отладки.
*/

try {
  lalala; // ошибка, переменная не определена!
} catch (err) {
  alert(err.name); // 'ReferenceError'
  alert(err.message); // 'lalala is not defined'
  alert(err.stack); // 'ReferenceError: lalala is not defined at (...стек вызовов)'

  // Можем также просто вывести ошибку целиком
  // Ошибка приводится к строке вида "name: message"
  alert(err); // 'ReferenceError: lalala is not defined'
}

/* 
Если нам не нужны детали ошибки, в catch можно её пропустить:
*/

try {
  // ...
} catch {
  //  <-- без (err)
  // ...
}

//_ Реальный случай использования «try…catch»

let json = '{ некорректный JSON }';

try {
  let user = JSON.parse(json); // <-- тут возникает ошибка...
  alert(user.name); // не сработает
} catch (e) {
  // ...выполнение прыгает сюда
  alert('Извините, в данных ошибка, мы попробуем получить их ещё раз.');
  alert(e.name);
  alert(e.message);
}

/* 
Здесь мы используем блок catch только для вывода сообщения,
но мы также можем сделать гораздо больше: отправить новый сетевой запрос, предложить
посетителю альтернативный способ, отослать информацию об ошибке на сервер для логирования
*/

//_ Генерация собственных ошибок

/* 
Что если json синтаксически корректен, но не содержит необходимого свойства name?
*/

let john = '{ "age": 30 }'; // данные неполны

try {
  let user = JSON.parse(john); // <-- выполнится без ошибок
  alert(user.name); // нет свойства name!
} catch (e) {
  alert('не выполнится');
}

/* 
Здесь JSON.parse выполнится без ошибок, но на самом деле отсутствие
свойства name для нас ошибка.

Для того, чтобы унифицировать обработку ошибок, мы воспользуемся оператором throw.
*/

//' Оператор «throw»

/* 
Оператор throw генерирует ошибку.

Синтаксис:

` throw <объект ошибки>

Технически в качестве объекта ошибки можно передать что угодно. Это может быть даже примитив,
число или строка, но всё же лучше, чтобы это был объект, желательно со свойствами name и message
(для совместимости со встроенными ошибками).

В JavaScript есть множество встроенных конструкторов для стандартных ошибок: Error, SyntaxError,
ReferenceError, TypeError и другие. Можно использовать и их для создания объектов ошибки.

Их синтаксис:
*/

let error1 = new Error(message);
let error2 = new SyntaxError(message);
let error3 = new ReferenceError(message);
// ...

/* 
Для встроенных ошибок (не для любых объектов, только для ошибок),
свойство name – это в точности имя конструктора. А свойство message берётся из аргумента.
*/

// Например:

let error = new Error('Ого, ошибка! o_O');

alert(error.name); // 'Error'
alert(error.message); // 'Ого, ошибка! o_O'

// Давайте посмотрим, какую ошибку генерирует JSON.parse:

try {
  JSON.parse('{ некорректный json o_O }');
} catch (e) {
  alert(e.name); // 'SyntaxError'
  alert(e.message); // 'Expected property name or '}' in JSON at position 2 (line 1 column 3)'
}

/* 
Как мы видим, это SyntaxError.

В нашем случае отсутствие свойства name – это ошибка, ведь пользователи должны иметь имена.
Сгенерируем её:
*/

let json1 = '{ "age": 30 }'; // данные неполны

try {
  let user = JSON.parse(json1); // <-- выполнится без ошибок

  if (!user.name) {
    throw new SyntaxError('Данные неполны: нет имени'); // (*)
  }

  alert(user.name);
} catch (e) {
  alert('JSON Error: ' + e.message); // 'JSON Error: Данные неполны: нет имени'
}

/* 
В строке (*) оператор throw генерирует ошибку SyntaxError с сообщением message.
Точно такого же вида, как генерирует сам JavaScript.

Выполнение блока try немедленно останавливается, и поток управления прыгает в catch.
*/

//_ Проброс исключения

/* 
В примере выше мы использовали try..catch для обработки некорректных данных.
А что, если в блоке try {...} возникнет другая неожиданная ошибка? Например, программная
*/

let json2 = '{ "age": 30 }'; // данные неполны

try {
  user = JSON.parse(json); // <-- забыл добавить "let" перед user

  // ...
} catch (err) {
  alert('JSON Error: ' + err); // 'JSON Error: ReferenceError: user is not defined'
  // (не JSON ошибка на самом деле)
}

/* 
По своей природе catch получает все свои ошибки из try. Здесь он получает неожиданную ошибку,
но всё также показывает то же самое сообщение "JSON Error". Это неправильно и затрудняет отладку кода.

К счастью, мы можем выяснить, какую ошибку мы получили по её свойству name
*/

/* 
Важно!
Блок catch должен обрабатывать только те ошибки, которые ему известны, и «пробрасывать» все остальные!

Техника «проброс исключения» выглядит так:

1. блок catch получает все ошибки.
2. в блоке catch(err) {...} мы анализируем объект ошибки err.
3. если мы не знаем как её обработать, тогда делаем throw err.
*/

// В коде ниже мы используем проброс исключения, catch обрабатывает только SyntaxError:

let json3 = '{ "age": 30 }'; // данные неполны
try {
  let user = JSON.parse(json3);

  if (!user.name) {
    throw new SyntaxError('Данные неполны: нет имени');
  }

  blabla(); // неожиданная ошибка

  alert(user.name);
} catch (e) {
  if (e.name == 'SyntaxError') {
    alert('JSON Error: ' + e.message);
  } else {
    throw e; // проброс (*)
  }
}

/* 
Ошибка в строке (*) из блока catch «выпадает наружу» и может быть поймана другой
внешней конструкцией try..catch (если есть), или «убьёт» скрипт.

Таким образом, блок catch фактически обрабатывает только те ошибки,
с которыми он знает, как справляться, и пропускает остальные.

Пример ниже демонстрирует, как такие ошибки могут быть пойманы
с помощью ещё одного уровня try..catch:
*/

function readData() {
  let json = '{ "age": 30 }';

  try {
    // ...
    blabla(); // ошибка!
  } catch (e) {
    // ...
    if (e.name != 'SyntaxError') {
      throw e; // проброс исключения (не знаю как это обработать)
    }
  }
}

try {
  readData();
} catch (e) {
  alert('Внешний catch поймал: ' + e); // поймал!
}

/* 
Здесь readData знает только, как обработать SyntaxError,
тогда как внешний блок try..catch знает, как обработать всё.
*/

//_ try…catch…finally

/* 
Конструкция try..catch может содержать ещё одну секцию: finally.

Если секция есть, то она выполняется в любом случае:

- после try, если не было ошибок,
- после catch, если ошибки были.

Расширенный синтаксис выглядит следующим образом:
*/

try {
  // ... пробуем выполнить код...
} catch (e) {
  // ... обрабатываем ошибки ...
} finally {
  // ... выполняем всегда ...
}

/* 
Секцию finally часто используют, когда мы начали что-то делать и хотим
завершить это вне зависимости от того, будет ошибка или нет.

try..catch..finally представляют локальную область видимости.
Если переменную объявить внутри блока, то она не будет видна за её пределами.

Блок finally срабатывает при любом выходе из try..catch, в том числе и return.

В примере ниже из try происходит return, но finally получает управление до того,
как контроль возвращается во внешний код.
*/

function func() {
  try {
    return 1;
  } catch (e) {
    /* ... */
  } finally {
    alert('finally');
  }
}

alert(func()); // сначала срабатывает alert из finally, а затем alert покажет 1
// сначала мы увидим в консоли 'finally', затем 1

/* 
Конструкция try..finally без секции catch также полезна.
Мы применяем её, когда не хотим здесь обрабатывать ошибки (пусть выпадут),
но хотим быть уверены, что начатые процессы завершились.
*/

function func() {
  // начать делать что-то, что требует завершения (например, измерения)
  try {
    // ...
  } finally {
    // завершить это, даже если все упадёт
  }
}

/* 
В приведённом выше коде ошибка всегда выпадает наружу, потому что тут нет блока catch.
Но finally отрабатывает до того, как поток управления выйдет из функции.
*/

//_ Глобальный catch

/* 
Давайте представим, что произошла фатальная ошибка (программная или что-то ещё ужасное)
снаружи try..catch, и скрипт упал.

Существует ли способ отреагировать на такие ситуации? Мы можем захотеть залогировать ошибку,
показать что-то пользователю (обычно они не видят сообщение об ошибке) и т.д.

Такого способа нет в спецификации, но обычно окружения предоставляют его,
потому что это весьма полезно. Например, в Node.js для этого есть process.on("uncaughtException").

А в браузере мы можем присвоить функцию специальному свойству window.onerror,
которая будет вызвана в случае необработанной ошибки.

Синтаксис:

` window.onerror = function(message, url, line, col, error) { ... };

message - сообщение об ошибке.
url - URL скрипта, в котором произошла ошибка.
line, col - номера строки и столбца, в которых произошла ошибка.
error - объект ошибки.
*/

// <script>
window.onerror = function (message, url, line, col, error) {
  alert(`${message}\n В ${line}:${col} на ${url}`);
};

function readData() {
  badFunc(); // Ой, что-то пошло не так!
}

readData();
// </script>

/* 
Роль глобального обработчика window.onerror обычно заключается не в восстановлении
выполнения скрипта – это скорее всего невозможно в случае программной ошибки,
а в отправке сообщения об ошибке разработчикам.
*/

// * итого

/* 
Конструкция try..catch позволяет обрабатывать ошибки во время исполнения кода.
Она позволяет запустить код и перехватить ошибки, которые могут в нём возникнуть.

Синтаксис:
*/

try {
  // исполняем код
} catch (err) {
  // если случилась ошибка, прыгаем сюда
  // err - это объект ошибки
} finally {
  // выполняется всегда после try/catch
}

/* 
Секций catch или finally может не быть, то есть более короткие конструкции
try..catch и try..finally также корректны.

Объекты ошибок содержат следующие свойства:

message – понятное человеку сообщение.
name – строка с именем ошибки (имя конструктора ошибки).
stack (нестандартное, но хорошо поддерживается) – стек на момент ошибки.

Если объект ошибки не нужен, мы можем пропустить его, используя catch {} вместо catch(err) {}.

Мы можем также генерировать собственные ошибки, используя оператор throw.
Аргументом throw может быть что угодно, но обычно это объект ошибки,
наследуемый от встроенного класса Error.

Проброс исключения – это очень важный приём обработки ошибок:
блок catch обычно ожидает и знает, как обработать определённый тип ошибок,
поэтому он должен пробрасывать дальше ошибки, о которых он не знает.

Даже если у нас нет try..catch, большинство сред позволяют настроить «глобальный»
обработчик ошибок, чтобы ловить ошибки, которые «выпадают наружу». В браузере это window.onerror.
*/
