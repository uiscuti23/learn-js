// * Массивы

/*
Массивы - это структура, представляющая собой упорядоченную коллекцию данных.
В массиве могут храниться элементы любого типа.
*/

//_ Объявление

/* 
Существует два варианта синтаксиса для создания пустого массива:

` let arr = new Array()
` let arr = []

Практически всегда используется второй вариант синтаксиса.
В скобках мы можем указать начальные значения элементов:
*/

let fruits = ['Яблоко', 'Апельсин', 'Слива'];

//_ Квадратные скобки [pos] и метод at(pos)

/*
Элементы массива нумеруются, начиная с нуля (0, 1, 2 ...).

Для работы с элементами мы можем использовать квадратные скобки,
указав внутри них номер (индекс) элемента.

Такой синтаксис позволяет:
*/

// - получить элемент:

alert(fruits[0]); // 'Яблоко'
alert(fruits[1]); // 'Апельсин'
alert(fruits[2]); // 'Слива'

// - заменить элемент:

fruits[2] = 'Груша'; // [ 'Яблоко', 'Апельсин', 'Груша' ]

// - добавить новый элемент:

fruits[3] = 'Лимон'; // [ 'Яблоко', 'Апельсин', 'Груша', 'Лимон' ]

// Пример получения элементов:

let array = ['apple', [1, 2], { name: 'John' }, () => alert('Hello!')];

alert(array[0]); // 'apple'
alert(array[1][0]); // 1
alert(array[2].name); // 'John'

array[3](); // 'Hello!'

// Мы можем использовать метод at вместо квадратных скобок:

alert(array.at(1).name); // 'John'

// Получение последних элементов:

let colors = ['red', 'green', 'blue'];

alert(colors[colors.length - 1]); // 'blue', свойство length содержит общее число элементов массива

alert(colors.at(-1)); // 'blue'

/*
Другими словами, arr.at(i):
- это ровно то же самое, что и arr[i], если i >= 0.
- для отрицательных значений i, он отступает от конца массива.
*/

//_ Немного о length

/*
Свойство length автоматически обновляется при изменении массива.
Если быть точными, он показывает не длину массива, а наибольший цифровой индекс плюс один
*/

let empty = [];
empty[10] = 'Яблоко';

alert(empty.length); // 11

/*
length можно перезаписать.
Если вручную увеличить его, то ничего интересного не произойдёт.
Если уменьшить, массив станет короче. Процесс необратим.
*/

let numArray = [1, 2, 3, 4, 5];

numArray.length = 2; // укорачиваем до двух элементов
alert(numArray); // [1, 2]

numArray.length = 5; // возвращаем length как было
alert(numArray[3]); // undefined: значения не восстановились

// Таким образом, самый простой способ очистить массив – это arr.length = 0;

//_ Перебор элементов

//' Цикл for

let fruitsArr = ['apple', 'orange', 'pear'];

for (let i = 0; i < fruitsArr.length; i++) {
  alert(fruitsArr[i]); // 'apple', 'orange', 'pear'
}

//' Цикл 'for..of'

for (let elem of array) {
  // тело цикла выполняется для каждого элемента массива
}

let fruits_arr = ['Яблоко', 'Апельсин', 'Слива'];

for (let fruit of fruits_arr) {
  alert(fruits_arr); // 'Яблоко', 'Апельсин', 'Слива'
}

/*
Цикл for..of не предоставляет доступа к номеру текущего элемента
*/

/*
Т.к массив является объектом, можно использовать вариант for..in,
но этот способ выполняет перебор всех свойств объекта, а не только цифровых.

Также цикл for..in оптимизирован под произвольные объекты, не на массивы,
и поэтому в 10-100 раз медленнее
*/

//' Метод forEach
// Позволяет запускать функцию для каждого элемента массива:

arr.forEach(function (item, index, array) {
  // ... делать что-то с item
});

let characters = ['Бильбо', 'Гэндальф', 'Назгул'];

characters.forEach(item => alert(item)); // 'Бильбо', 'Гэндальф', 'Назгул'

characters.forEach((item, index, array) => {
  alert(`У ${item} индекс ${index} в ${array}`); // 'У Бильбо индекс 0 в Бильбо,Гэндальф,Назгул' ...
});

/*
Результат функции (если она что-то возвращает) отбрасывается и
игнорируется
*/

//_ Методы pop/push, shift/unshift

/*
1. Очередь - упорядоченная коллекция элементов, поддерживающая 2 вида операций:

- добавление элемента в конец очереди (push)
- удаление элемента в начале, сдвигая очередь так, что второй элемент становится первым (shift)

2. Стуктура данных, называемая стек, поддерживает два вида операций:
- добавление элемента в конец (push)
- удаление последнего элемента (pop)

Массивы в JS могут работать и как очередь, и как стек.
Мы можем добавлять/удалять элементы как в начало/(е), так и в конец/(це) массива

Методы, работающие ...:
- с концом массива: pop и push
- с началом массива: shift и unshift
*/

//' pop - удаляет последний элемент из массива и возвращает его

let fruits = ['Яблоко', 'Апельсин', 'Груша'];

alert(fruits.pop()); // удаляем 'Груша' и выводим его

alert(fruits); // 'Яблоко', 'Апельсин'

/*
И fruits.pop() и fruits.at(-1) возвращают последний элемент массива,
но fruits.pop() также изменяет массив, удаляя его.
*/

//' push - добавляет элементы в конец массива

let fruits = ['Яблоко', 'Апельсин'];

fruits.push('Груша', 'Лимон');
alert(fruits); // 'Яблоко', 'Апельсин', 'Груша', 'Лимон'

/*
Вызов fruits.push(...) равнозначен fruits[fruits.length] = ...,
если мы хотим добавить один элемент
*/

//' shift - удаляет из массива первый элемент и возвращает его:

let fruits = ['Яблоко', 'Апельсин', 'Груша'];

alert(fruits.shift()); // удаляем 'Яблоко' и выводим его
alert(fruits); // 'Апельсин', 'Груша'

//' unshift - добавляет элементы в начало массива:

let fruits = ['Апельсин', 'Груша'];

fruits.unshift('Яблоко', 'Ананас');
alert(fruits); // 'Яблоко', 'Ананас', 'Апельсин', 'Груша'

/*
Методы push/pop выполняются быстро, а shift/unshift - медленно.

Методы pop/push не требуют перемещения элементов массива (изменения индекса и местоположения)
при удалении последнего элемента или при добавлении новых элементов, в отличии от shift/unshift.
Именно поэтому они выполняется очень быстро.
*/

//_ Внутреннее устройство массива

/* 
Массив – это особый подвид объектов.

Квадратные скобки, используемые для того, чтобы получить доступ к свойству arr[0] –
это по сути обычный синтаксис доступа по ключу, как obj[key],
где в роли obj у нас arr, а в качестве ключа – числовой индекс.

Массивы расширяют объекты, так как предусматривают специальные методы
для работы с упорядоченными коллекциями данных, а также свойство length.
Но в основе всё равно лежит объект.

Массив следует считать особой структурой, позволяющей работать с упорядоченными данными.
Для этого массивы предоставляют специальные методы.

Массивы тщательно настроены в движках JavaScript для работы с однотипными упорядоченными данными,
поэтому, пожалуйста, используйте их именно в таких случаях.

Варианты неправильного применения массива:

- добавление нечислового свойства, например: arr.test = 5
- создание «дыр», например: добавление arr[0], затем arr[1000] (между ними ничего нет)
- заполнение массива в обратном порядке, например: arr[1000], arr[999] и т.д
*/

//_ new Array()

// Существует ещё один вариант синтаксиса для создания массива:

let arr = new Array('apple', 'banana', 'и тд');

/* 
Он редко применяется, так как квадратные скобки [] короче.

Кроме того, у него есть хитрая особенность - если new Array
вызывается с одним аргументом, который представляет собой число,
он создаёт массив без элементов, но с заданной длиной:
*/

let numArr = new Array(2); // [empty × 2]

alert(numArr.length); // 2
alert(numArr[0]); // undefined

// В коде, представленном выше, в new Array(number) все элементы равны undefined

//_ Метод toString

// Метод toString в массиве возвращает список элементов, разделённых запятыми:

let numbers = [1, 2, 3];

alert(String(numbers)); // '1,2,3'

/*
Массивы не имеют ни Symbol.toPrimitive, ни функционирующего valueOf,
они реализуют только преобразование toString:
*/

alert([] + 1); // '1'
alert([1] + 1); // '11'
alert([1, 2] + 1); // '1,21'

//_ Не сравнивайте массивы при помощи ==

/*
У этого оператора нет специального подхода к массивам. Он работает
с ними как с объектами.

Если сравнить массивы с помощью ==, то они никогда не будут одинаковыми,
если только мы не сравним две переменные, которые ссылаются
на один и тот же объект:
*/

alert([] == []); // false
alert([0] == [0]); // false

// Сравнение с примитивами:

alert(0 == []); // true
alert('0' == []); // false

/*
Массив [] преобразуется в примитив с целью сравнения
и становится пустой строкой ''.

После того, как [] был преобразован в '' продолжится процесс
сравнения с примитивами
*/

alert(0 == ''); // true, так как '' преобразуется в число 0
alert('0' == ''); // false, разные строки

/*
Не используйте оператор == для сравнения массивов.
Вместо этого сравните их по элементам в цикле или используя методы итерации
*/

//_ Array.isArray

/* 
Массивы не образуют отдельный тип данных. Они основаны на объектах.

Поэтому typeof не может отличить простой объект от массива:
*/

alert(typeof {}); // object
alert(typeof []); // object

/* 
Статический метод Array.isArray(value) проверяет,
является ли переданный аргумент массивом.

Он возвращает true, если value массив, и false, если нет.
*/

alert(Array.isArray({})); // false
alert(Array.isArray([])); // true

// Дополнительно

//_ Необязательный параметр 'thisArg'

/*
Почти все методы массива, которые вызывают функции – такие как find,
filter, map, за исключением метода sort, принимают необязательный
параметр thisArg.
*/
arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
// thisArg - это необязательный последний аргумент

/*
Значение параметра thisArg становится this для func.

Например, тут мы используем метод canJoin объекта army как фильтр,
и thisArg передаёт ему контекст:
*/

let army = {
  minAge: 18,
  maxAge: 27,

  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  },
};

let users_arr = [
  { name: 'Anderson', age: 16 },
  { name: 'Calvin', age: 20 },
  { name: 'Dwight', age: 23 },
  { name: 'Ethan', age: 30 },
];

// найти пользователей, для которых army.canJoin возвращает true
let soldiers = users_arr.filter(army.canJoin, army);

alert(soldiers.length); // 2
alert(soldiers[0].age); // 20
alert(soldiers[1].age); // 23
